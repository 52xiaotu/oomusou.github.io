<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[點燈坊]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://oomusou.io/"/>
  <updated>2018-03-25T05:34:09.559Z</updated>
  <id>http://oomusou.io/</id>
  
  <author>
    <name><![CDATA[真 OO無双]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[F# 之 Opition 型別簡介]]></title>
    <link href="http://oomusou.io/fsharp/option/"/>
    <id>http://oomusou.io/fsharp/option/</id>
    <published>2018-03-25T12:23:43.000Z</published>
    <updated>2018-03-25T05:34:09.559Z</updated>
    <content type="html"><![CDATA[<p>當我們要根據使用者輸入的 <code>OrderId</code> 到資料庫搜尋 <code>訂單資料</code>，若找的到就回傳該筆訂單，若搜尋不到呢？一般而言有兩種處理方式，傳回 <code>null</code> 或拋出 exception，但實務上仍然會因為忘記處理 <code>null</code> 或 exception，而在 run-time 得到 <code>NullReferenceException</code>，這種常見的錯誤，是否能在 compile-time 獲得解決呢？</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>C# 7.2<br>F# 4.1</p>
<h2 id="Null">Null</h2><hr>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order = Order.GetById(<span class="number">10</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, order.Name));</span><br></pre></td></tr></table></figure>
<p><code>getById()</code> 會根據 user 輸入的 <code>OrderId</code>，到資料庫搜尋 <code>訂單資料</code>，junior 常會這樣寫程式。</p>
<p>這樣的寫法乍看之下沒問題，但 code review 時一定會被 sernior 問：</p>
<blockquote>
<p>Q：若找不到訂單資料而回傳 <code>null</code> 該怎麼辦？</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order = Order.GetById(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (order == <span class="keyword">null</span>) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"No orders found."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, order.Name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Junior 會乖乖的補上  <code>null</code> 判斷，如此才不會在 run-time 得到 <code>NullReferenceException</code>。</p>
<p>若使用 <code>null</code> 代表 <code>找不到資料</code>，會有幾個問題：</p>
<ol>
<li>必須額外加上 <code>null</code> 判斷，否則在 run-time 會得到 <code>NullReferenceException</code></li>
<li>因為 <code>null</code> 也是 <code>Order</code> 型別，所以 compiler 對於 <code>null</code> 檢查無能為力，只能靠 developer 自己的細心，或靠 unit test 的 coverage 完整加以保護</li>
<li>每個 function 都可能傳回 <code>null</code>，是否每個 function 都必須判斷 <code>null</code>？如此 code 會變得很髒</li>
</ol>
<h2 id="Exception">Exception</h2><hr>
<blockquote>
<p>Ａ：<code>null</code> 的確不好，所以若找不到訂單資料就拋 exception</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> order = Order.GetById(<span class="number">10</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, order.Name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (OrderNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"No orders found."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exception 雖然比 <code>null</code> 好，但依然有些問題：</p>
<ol>
<li><code>getById()</code> 回傳 <code>Order</code> 型別，你該如何得知到底該處理 <code>null</code> 還是要處理 exception？靠文件還是要靠團隊共識？</li>
<li>若 developer 忘記處理 exception，compiler 也無能為力，只能靠 developer 自己的細心，或靠 unit test 的 coverage 完整加以保護</li>
<li>每個 function 都可能傳回 exception，是否每個 function 都必須處理 exception？<code>try catch</code> 寫法其實也好不到哪裡，一樣會把 code 弄髒</li>
</ol>
<h2 id="Option">Option</h2><hr>
<p>FP 語言對 <code>null</code> 與 exception 提出了另外一種解決方案，在 OCaml 與 F# 有 <code>Option</code> 型別，在 Haskell 有 <code>Maybe</code> 型別，讓我們可以在 compiler-time 就能處理，也不會把 code 弄髒。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> System</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Order</span> </span>= &#123;</span><br><span class="line">    Id: int</span><br><span class="line">    Name: string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;EntryPoint&gt;]</span></span><br><span class="line"><span class="keyword">let</span> main argv =</span><br><span class="line">    <span class="keyword">let</span> getById id = Some &#123; Id = <span class="number">10</span>; Name = <span class="string">"Sam"</span> &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> order = getById <span class="number">10</span></span><br><span class="line">    <span class="keyword">match</span> order <span class="keyword">with</span></span><br><span class="line">    | Some order -&gt; printfn <span class="string">"%s"</span> order.Name</span><br><span class="line">    | None       -&gt; printfn <span class="string">"No orders found."</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="number">0</span> <span class="comment">// return an integer exit code</span></span><br></pre></td></tr></table></figure>
<p>由於 <code>getById()</code> 可能傳回 <code>訂單資料</code>，也可能找不到資料，因此回傳的就不是 <code>Order</code> 型別，也不是 <code>null</code>，而是另外一個型別 <code>Order option</code> 型別，也就是 <code>Option&lt;Order&gt;</code>。</p>
<p>再搭配 Pattern Matching 對 <code>Option</code> 做處理，即可同時對 <code>找到訂單資料</code> 與 <code>找不到訂單資料</code> 進行處理。</p>
<p><img src="/images/fsharp/option/option000.png" alt="ption00"></p>
<p><code>getById()</code> 回傳的型別不再是 <code>Order</code> 型別 ，而是 <code>Order option</code> 型別，這是個 <code>Option</code> 型別。</p>
<blockquote>
<p>Q：什麼是 <code>Option</code> 型別呢 ?</p>
</blockquote>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Option</span>&lt;<span class="title">'a</span>&gt; </span>=</span><br><span class="line">    | Some <span class="keyword">of</span> <span class="attribute">'a</span></span><br><span class="line">    | None</span><br></pre></td></tr></table></figure>
<p><code>Option</code> 事實上就是 <code>Union</code> 型別，只是已經是先定義好  <code>Some</code> 與 <code>None</code> 兩個 case。</p>
<p>重點是 <code>null</code> 是 <code>Order</code> 型別，但 <code>None</code> 不是 <code>Order</code> 型別，而是 <code>Option</code> 型別。</p>
<blockquote>
<p>Q : <code>Option</code> 型別對於寫程式有什麼用處？</p>
</blockquote>
<p>之前因為 <code>null</code> 屬於 <code>Order</code> 型別，也無法確定 <code>getById()</code> 是否拋出 exception 而造成困擾，但若確認 <code>getById()</code> 回傳的是 <code>Option</code> 而不是  <code>Order</code> 型別，則 client 就有心理準備，知道要怎麼處理 <code>Option</code>，不需靠文件也不需靠團隊共識。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> order = Order.getById <span class="number">10</span></span><br><span class="line">printfn <span class="string">"%s"</span> order.Name</span><br></pre></td></tr></table></figure>
<p>就算 junior 寫出這樣的程式碼，不用等 senior 來 code review，compiler 已經編譯錯誤，因為 <code>order</code> 為 <code>Option</code> 型別，不是 <code>Order</code> 型別，因此無法直接由 <code>order.Name</code> 取值。</p>
<p><img src="/images/fsharp/option/option001.png" alt="ption00"></p>
<p>因為 <code>order</code> 不是 <code>Order</code> 型別，所以沒有 <code>Name</code> 可取，在 Intellisense 階段就已經提出警告。</p>
<p>為了要從 <code>Option</code> 取值，就一定得搭配 Pattern Matching。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> order <span class="keyword">with</span></span><br><span class="line">| Some order -&gt; printfn <span class="string">"%s"</span> order.Name</span><br><span class="line">| None       -&gt; printfn <span class="string">"No orders found."</span></span><br></pre></td></tr></table></figure>
<p>透過 Pattern Match 的 Some 將 <code>order</code> 取出來。</p>
<p><img src="/images/fsharp/option/option002.png" alt="ption00"></p>
<p>若在 Pattern Matching 只寫了 <code>Some</code>，忘記寫 <code>None</code> ，compiler 也會提出警告。</p>
<h2 id="Summary">Summary</h2><hr>
<p><code>Option</code> 型別具有以下優點</p>
<ol>
<li>透過 <code>Option</code> 型別，client 可以明確得知該 function 可能傳回資料，也可能不傳回資料，因此會有明確因應對策，而不像 <code>null</code> 與 exception 那樣</li>
<li>由於 <code>Option</code> 型別不等於原本資料型別，因此 junior 無法直接對 Option 取值而造成 <code>NullReferenceException</code></li>
<li>一定得用 Pattern Matching 處裡 <code>Option</code> 型別，若忘記使用 Pattern Matching 或 case 不夠完整，compiler 會在 compile-time 就加以警告，不會有忘記處理 <code>Option</code> 的問題</li>
<li>Pattern Matching 遠比 <code>null checking</code> 與 <code>exception handling</code> 優雅，也不會把 code 弄髒</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>好的程式語言就是在 compile-time 就幫我們找到錯誤，而不是要自己寫程式在 run-time 處理</li>
<li><code>null</code> 與 exception 除了常常忘記處理而造成 <code>NullReferenceException</code>， 也很容易將 code 弄髒；但 <code>Option</code> + Pattern Matching 則可透過 compiler 幫我們檢查，code 也比較優雅</li>
<li>JavaScript 已經有 <code>Option</code> 型別草案，希望能儘早成為 JavaScript 標準</li>
</ul>
<h2 id="Reference">Reference</h2><p><a href="https://docs.microsoft.com/en-us/" target="_blank" rel="external">Microsoft Docs</a>, <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/options" target="_blank" rel="external">Options</a><br><a href="https://fsharpforfunandprofit.com/" target="_blank" rel="external">F# for fun and profit</a>, <a href="https://fsharpforfunandprofit.com/posts/the-option-type/" target="_blank" rel="external">The Option type</a><br><a href="https://twitter.com/David_Raab" target="_blank" rel="external">David Raad</a>, <a href="http://sidburn.github.io/blog/2016/03/20/null-is-evil" target="_blank" rel="external">null is Evil</a><br><a href="https://twitter.com/David_Raab" target="_blank" rel="external">David Raad</a>, <a href="http://sidburn.github.io/blog/2016/03/25/exceptions-are-evil" target="_blank" rel="external">Exceptions are Evil</a><br><a href="https://twitter.com/David_Raab" target="_blank" rel="external">David Raad</a>, <a href="http://sidburn.github.io/blog/2016/04/11/optionals" target="_blank" rel="external">Optionals</a><br><a href="https://twitter.com/David_Raab" target="_blank" rel="external">David Raad</a>, <a href="http://sidburn.github.io/blog/2016/05/11/option-module" target="_blank" rel="external">The Option Module</a></p>
]]></content>
    <summary type="html">
    <![CDATA[比 null 與 exception 更優雅的處理方式]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
      <category term="F#" scheme="http://oomusou.io/tags/F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 F# 實現 Strategy Pattern ?]]></title>
    <link href="http://oomusou.io/fsharp/strategy/"/>
    <id>http://oomusou.io/fsharp/strategy/</id>
    <published>2018-03-23T12:23:43.000Z</published>
    <updated>2018-03-23T07:25:13.839Z</updated>
    <content type="html"><![CDATA[<p>Strategy Pattern 是 OOP 中最著名的 Design Pattern，幾乎可以說是 OOP 中 『解耦合』最經典的應用，F# 既然是 Function First Language，就讓我們以 function 的角度重新思考什麼是 『解耦合』。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101<br>JetBrains Rider 2017.3.1<br>F# 4.1</p>
<h2 id="User_Story">User Story</h2><hr>
<p>假設你在處理訂單，訂單的折扣方式有兩種</p>
<ul>
<li>超過 1000 元，則 <code>滿千送百</code></li>
<li>不到 1000 元，則 <code>全館8折</code></li>
</ul>
<h2 id="Task">Task</h2><hr>
<p>直接使用 FP 的思維完成需求。</p>
<h2 id="Definition">Definition</h2><hr>
<blockquote>
<p>Strategy Pattern</p>
<p>將不同演算法抽象化成相同 interface，讓高階模組與實際演算法解耦合，而彼此僅相依於 interface，進而可動態切換演算法</p>
</blockquote>
<p><img src="/images/fsharp/strategy/strategy000.svg" alt="trategy00"></p>
<p>首先思考 Strategy Pattern 的本質：</p>
<ol>
<li><code>Strategy</code> 必須與 <code>Context</code> 解耦合</li>
<li><code>Strategy</code> 必須能動態切換</li>
</ol>
<p>只要能達到這兩個目標，就算完成了 Strategy Pattern。</p>
<h2 id="OOP_思考方式">OOP 思考方式</h2><hr>
<p>OOP 強調是 data 與 function 合一，認為什麼都是物件，所以 strategy 也是物件。</p>
<p>要將不同的 strategy <code>抽象化</code> 看成相同的物件，才能使用 <code>多型</code> 操作，所以要設計 <code>interface</code> 訂定 <code>抽象化</code> 的標準。</p>
<p>也就是 OOP 是將焦點放在 <code>不同的部分</code>，進而將 <code>不同的部分</code> 抽象化成 Inteface。</p>
<h2 id="FP_思考方式">FP 思考方式</h2><hr>
<p>FP 強調是 data 與 function 分開，data 有 Type System，function 有 Higher Order Function、Function Composition，因為 strategy 只是功能，所以是 function。</p>
<p>要將相同的部分抽出為 Higher Order Function，不同 strategy 抽成獨立 funciton，再將 strategy 以參數的方式傳入 Higher Order Function。</p>
<p>也就是 FP 是將焦點放在 <code>相同的部分</code>，進而將 <code>相同的部分</code> 抽成 Higher Order Function。</p>
<h2 id="Implemetation">Implemetation</h2><hr>
<p><strong>Strategy.fs</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> OrderLibrary</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> PriceStrategy =</span><br><span class="line">    <span class="keyword">let</span> rebateStrategy price = price - <span class="number">100.0</span></span><br><span class="line">    <span class="keyword">let</span> discountStrategy discount price = price * discount * <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>將 <code>買千送百</code> 以 <code>rebateStrategy()</code> 表示。</p>
<p>將 <code>全館8折</code> 以 <code>discountStrategy()</code> 表示。</p>
<p>特別注意 <code>rebateStrategy()</code> 與 <code>discountStrategy()</code> 的 singnature 並不一樣，傳統 OOP 在使用 Strategy Pattern 時，必須先定義 strategy interface，但只要遇到 strategy 間 signature 不同時就很困擾，甚至要動用 Adapter Pattern。</p>
<p>但因為 FP 沒有 interface 概念，所以不需要為不同的 strategy <code>抽象化</code> 成相同 interface，故也沒有 interface 很難開的困擾。</p>
<p><strong>OrderService.fs</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> OrderLibrary</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> OrderService =</span><br><span class="line">    <span class="keyword">let</span> strategyFactory price = </span><br><span class="line">        <span class="keyword">match</span> (price &gt; <span class="number">1000.0</span>) <span class="keyword">with</span></span><br><span class="line">        | <span class="keyword">true</span>  -&gt; PriceStrategy.rebateStrategy</span><br><span class="line">        | <span class="keyword">false</span> -&gt; PriceStrategy.discountStrategy <span class="number">0.8</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> getPrice price =</span><br><span class="line">        price</span><br><span class="line">        |&gt; strategyFactory price</span><br></pre></td></tr></table></figure>
<p>第 4 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strategyFactory price = </span><br><span class="line">    <span class="keyword">match</span> (price &gt; <span class="number">1000.0</span>) <span class="keyword">with</span></span><br><span class="line">    | <span class="keyword">true</span>  -&gt; PriceStrategy.rebateStrategy</span><br><span class="line">    | <span class="keyword">false</span> -&gt; PriceStrategy.discountStrategy <span class="number">0.8</span></span><br></pre></td></tr></table></figure>
<p>既然有不同的 strategy，就會有選擇 strategy 的邏輯，所以 factory 少不了，只是從 OOP 的 factory class 退化成 factory function。</p>
<p>Strategy 的選擇，使用 FP 的 Pattern Matching 最適合，根據不同的條件回傳不同的 function。</p>
<p><img src="/images/fsharp/strategy/strategy001.png" alt="trategy00"></p>
<p>F# 雖然不用寫型別，但對於型別檢查依然非常嚴格，<code>strategyFactory()</code> 被 Type Inference 推導為 <code>float -&gt; (float -&gt; float)</code>，也就是我們必須回傳一個 <code>float -&gt; float</code> 的 function。</p>
<p>在 C# 我們必須明確使用 <code>delegate</code> 或 <code>Func&lt;float, float&gt;</code> 定義 strategy 的 signature，但在 F# 都省了，因此程式碼變得非常精簡，兼具強型別語言與弱型別語言的優點。</p>
<p>但 <code>rebateStrategy()</code> 與 <code>discountStrategy()</code> 的 signature 畢竟不一樣，因此在使用 Pattern Matching 時，必須先將  <code>float -&gt; float</code> 整理好，因爲 F# 支援 Currying，<code>discountStrategy 0.8</code> 會自動回傳 <code>float -&gt; float</code> 的 function，如此將符合 Pattern Matching 對型別的要求。</p>
<blockquote>
<p>FP 不用 interface，不代表沒有型別要求，透過 Currying，可以解決 OOP 因為需求不同難開 interface 的老問題，只要在最後 signature 一樣即可，並不要求設計 function 時都要有相同的 signature，可使用 Currying 逐步完成 signature 要求</p>
</blockquote>
<p>第 9 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getPrice price =</span><br><span class="line">    price</span><br><span class="line">    |&gt; strategyFactory price</span><br></pre></td></tr></table></figure>
<p>將 price 以 Pipeline 方式傳給對的 strategy 計算，其中 <code>strategyFactory price</code> 將傳回對的 strategy。</p>
<p><strong>Program.fs</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> System</span><br><span class="line"><span class="keyword">open</span> OrderLibrary</span><br><span class="line"></span><br><span class="line"><span class="annotation">[&lt;EntryPoint&gt;]</span></span><br><span class="line"><span class="keyword">let</span> main argv =</span><br><span class="line">    <span class="number">1200.0</span></span><br><span class="line">    |&gt; OrderService.getPrice</span><br><span class="line">    |&gt; printfn <span class="string">"%f"</span></span><br><span class="line"></span><br><span class="line">    <span class="number">800.0</span></span><br><span class="line">    |&gt; OrderService.getPrice</span><br><span class="line">    |&gt; printfn <span class="string">"%f"</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">0</span> <span class="comment">// return an integer exit code</span></span><br></pre></td></tr></table></figure>
<p>將各種 price 以 Pipeline 方式傳給 <code>OrderService.getPrice()</code> 計算，並將結果傳給 <code>printfn()</code> 顯示。</p>
<h2 id="Retrospective">Retrospective</h2><hr>
<p>回想 Strategy Pattern 的本質：</p>
<ol>
<li><code>Strategy</code> 必須與 <code>Context</code> 解耦合</li>
<li><code>Strategy</code> 必須能動態切換</li>
</ol>
<p>FP 雖然沒有定義 interface，但 strategy 已經與 context 實質解耦合，strategy 都必須嚴格遵守 <code>float -&gt; float</code> 的 signature，任何 <code>float -&gt; float</code> 的 function 都可視為 strategy。</p>
<p>只要遵守 <code>float -&gt; float</code> 的 strategy，就能被 Pattern Matching 動態切換。</p>
<p>所以 FP 版的 Strategy Pattern 雖然沒有 interface 也沒有 <code>多型</code>，但本質與 OOP 是相同的。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>不用很糾結一定要使用 interface 與 <code>多型</code>，重點在於 <code>解耦合</code> 與 <code>動態切換</code>，FP 使用 Higher Order Function 與 Pattern Matching 也能達成相同的目標</li>
<li>FP 的 Higher Order Function，可以實現 <code>DRY</code> 原則，FP 設計時要將焦點放在 <code>相同的部分</code>，抽出 Higher Order Function 後，再透過 Function Composition 組合成新的 function</li>
<li>FP 的 Pattern Matching，可以實現 OOP 的 <code>多型</code>，藉此達到 <code>動態切換</code> 需求</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/FSharpCore2OrderStrategy" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[以 FP 的角度思考解耦合]]>
    
    </summary>
    
      <category term="Design Pattern" scheme="http://oomusou.io/tags/Design-Pattern/"/>
    
      <category term="F#" scheme="http://oomusou.io/tags/F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探討 .NET Core 之 Type Forwarding]]></title>
    <link href="http://oomusou.io/netcore/type-forwarding/"/>
    <id>http://oomusou.io/netcore/type-forwarding/</id>
    <published>2018-03-22T12:23:43.000Z</published>
    <updated>2018-03-22T09:47:52.805Z</updated>
    <content type="html"><![CDATA[<p>.NET Core 能跨平台看似很神奇，事實上底層所使用的技術為 Type Forwarding，說穿了就是 Proxy Pattern 的應用。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101<br>JetBrains Rider 2017.3.1<br>Visual Studio 2017 15.6.2</p>
<h2 id="Definition">Definition</h2><hr>
<p>Client 在不改變 assembly reference 狀態下，就可使用其他 assembly 所提供的 class。</p>
<p><img src="/images/netcore/type-forwarding/type007.svg" alt="ype00"></p>
<p>.NET App 會直接與 <code>Assembly A</code> 耦合，僅能使用 <code>Assembly A</code> 的 <code>MyClass</code>。</p>
<p><img src="/images/netcore/type-forwarding/type008.svg" alt="ype00"></p>
<p>.NET App 依然只與 <code>Assembly A</code> 耦合，但卻能夠透過 Type Forwarding 使用 <code>Assembly B</code> 的 <code>MyClass</code>。</p>
<h2 id="實戰_Type_Forwarding">實戰 Type Forwarding</h2><hr>
<h3 id="建立_ClassLibrary1">建立 ClassLibrary1</h3><p><strong>Class1.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ClassLibrary1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ClassLibrary1</code> assembly 建立 <code>Class1.Sum()</code>。</p>
<h3 id="建立_ConsoleApp">建立 ConsoleApp</h3><p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> ClassLibrary1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> object1 = <span class="keyword">new</span> Class1();</span><br><span class="line">            <span class="keyword">var</span> result = object1.Sum(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ConsoleApp</code> 使用 <code>ClassLibrary1</code> 的 <code>Class1.Sum()</code>。</p>
<p><img src="/images/netcore/type-forwarding/type000.png" alt="ype00"></p>
<ol>
<li>目前只有 <code>ClassLibrary1</code> 與 <code>ConsoleApp</code></li>
<li>執行結果為 <code>2</code></li>
<li><code>ConsoleApp</code> 的 project reference 只有 <code>ClassLibrary1</code></li>
</ol>
<h3 id="建立_ClassLibrary2">建立 ClassLibrary2</h3><p><strong>Class1.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ClassLibrary1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 <code>ClassLibrary1</code> 的 <code>Class1.cs</code> 全部程式碼搬到 <code>ClassLibrary2</code>。</p>
<h3 id="ClassLibrary1_使用_Type_Forwarding">ClassLibrary1 使用 Type Forwarding</h3><p><strong>Class1.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line">[assembly:TypeForwardedTo(<span class="keyword">typeof</span>(ClassLibrary1.Class1))]</span><br></pre></td></tr></table></figure>
<p>因為 <code>ClassLibrary1</code> 的 <code>Class1.cs</code> 程式碼已經搬到 <code>ClassLibrary2</code>，將原本 <code>ClassLibrary1</code> 的 <code>Class1.cs</code> 加上 Type Forwarding。</p>
<p>當 <code>ConsoleApp</code> 使用 <code>ClassLibrary1</code> assembly 的 <code>ClassLibrary1.Class1</code> 時，會自動 Type Forwarding 到 <code>ClassLibrary2</code> assembly 的 <code>ClassLibrary1.Class1</code> 。</p>
<p>Rebuild 整個 solution 的 3 個 project 並執行。</p>
<p><img src="/images/netcore/type-forwarding/type001.png" alt="ype00"></p>
<ol>
<li>目前有 <code>ClassLibrary1</code> 、<code>ClassLibrary2</code> 與 <code>ConsoleApp</code></li>
<li>執行結果依然為 <code>2</code></li>
<li>原本 <code>ConsoleApp</code> 的 project reference 只有 <code>ClassLibrary1</code>，因為 Type Forwarding，所以現在也有了 <code>ClassLibrary2</code></li>
</ol>
<blockquote>
<p>我們並沒有對 <code>ConsoleApp</code> 將 <code>ClassLibrary2</code> 加入 project reference，而是因為 Type Forwarding</p>
</blockquote>
<h2 id="觀察_netstandard_Assembly">觀察 netstandard Assembly</h2><hr>
<p>Metapackage 與 .NET Standard 談了這麼多，是否感覺很抽象呢 ? 讓我們以反組譯 <code>netstandard</code> Assembly 來理解其中的黑魔法。</p>
<p>使用 Visual Studio 2017 開啟 solution。</p>
<p><img src="/images/netcore/type-forwarding/type002.png" alt="ype00"></p>
<p><strong><em>View -&gt; Object Browser</em></strong> 開啟 Object Browser，可以讓我們看到整個 solution 所用到的 assembly。</p>
<ol>
<li>展開 <code>ClassLibrary1</code>，看不到任何 namespace 與 class，因為我們已經在 <code>ClassLibrary1</code> 使用 Type Forwarding。</li>
<li>展開 <code>ClassLibrary2</code>，我們看到了 <code>ClassLibrary1</code> namespace 與 <code>Class1</code> class。</li>
</ol>
<blockquote>
<p>若 assembly 使用了 Type Forwarding，使用 Object Browser 將看不到該 assembly 任何實作的 namespace 與 class</p>
</blockquote>
<p><img src="/images/netcore/type-forwarding/type003.png" alt="ype00"></p>
<ol>
<li>點擊 <code>mscorlib</code> 與 <code>netstandard</code> 兩個 assembly ，亦發現沒有任何實作的 namespace 與 class，其中 <code>mscorlib</code> 就是 <code>Microsoft.NETCore.App</code>，而 <code>netstandard</code> 就是 <code>NETStandard.Library</code></li>
<li>顯示 <code>netstandard</code> assembly 的實際路徑</li>
</ol>
<blockquote>
<p>由於 <code>mscorlib</code> 與 <code>netstandard</code> 都沒有任何實作，根據 <code>ClassLibrary1</code> 的經驗推測，很可能也是用了 Type Forwarding </p>
</blockquote>
<p><img src="/images/netcore/type-forwarding/type004.png" alt="ype00"></p>
<p>使用 ILSpy 反組譯 <code>netstandard</code> assembly，我們可以發現真的沒有任何實作，但大量使用了 Type Forwarding。</p>
<p>在傳統 .NET Framework 世界裡，我們是直接參考 .NET Framework 內某個 assembly 的 class，也因此與 Windows 平台的 assembly 的 class 耦合。</p>
<p>但在 .NET Core 世界裡，我們改參考 .NET Standard，再由 .NET Standard 透過 Type Forwarding 方式參考實際 host 的 assembly 的 class，若 host  是 macOS，則參考 macOS 上的 assembly 的 class，若 host 是 Linux，則參考 Linux 上的 assembly 的 class。</p>
<blockquote>
<p>因為 client 只與有 Type Forwarding 的 .NET Standard 耦合，而沒與特定平台的 class 耦合，所以 .NET Core 能達到跨平台，在不同 host os 下，不用編譯就可以自動找到正確的 class</p>
</blockquote>
<h2 id="Proxy_Pattern">Proxy Pattern</h2><hr>
<blockquote>
<p>Proxy Pattern</p>
<p>Client 為了避免與實際物件耦合，改透過相同 interface 的 <code>白手套</code> proxy 耦合，再由 proxy 負責與實際物件溝通</p>
</blockquote>
<p><img src="/images/netcore/type-forwarding/type005.svg" alt="ype00"></p>
<p><code>Client</code> 實際上要使用 <code>RealSubject</code>，但為了將 <code>RealSubject</code> 與 <code>Client</code> 解耦合，<code>Client</code> 只與相同 interface 的 <code>Proxy</code> 耦合，再由白手套 <code>Proxy</code> 使用 <code>RealSubject</code>。</p>
<p><strong>.NET Standard</strong></p>
<p><img src="/images/netcore/type-forwarding/type006.svg" alt="ype00"></p>
<p><code>Client</code> 實際上要使用各平台的 <code>.NET Core SDK</code>，但為了將各平台的 <code>.NET Core SDK</code> 與 <code>Client</code> 解耦合，<code>Client</code> 只與一樣遵守 .NET Standard 的 <code>netstandard</code> 耦合，再由白手套 <code>netstandard</code> 透過 Type Forwarding 使用各平台的 <code>.NET Core SDK</code>。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Metapackage 與 .NET Standard 不是什麼黑魔法，只是一個使用 Type Forwarding 的 DLL</li>
<li>我們只要跟 .NET Standard 耦合即可，它會使用 Type Forwarding 幫我們使用各平台實際的 class</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/TypeForwarding" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/" target="_blank" rel="external">Microsoft Docs</a>, <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/type-forwarding-in-the-common-language-runtime" target="_blank" rel="external">Type Fowarding in the Common Language Runtime</a></p>
]]></content>
    <summary type="html">
    <![CDATA[解開 .NET Core 跨平台的黑魔法]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET Core 之 Metapackage 簡介]]></title>
    <link href="http://oomusou.io/netcore/metapackage/"/>
    <id>http://oomusou.io/netcore/metapackage/</id>
    <published>2018-03-21T13:23:43.000Z</published>
    <updated>2018-03-23T07:43:01.747Z</updated>
    <content type="html"><![CDATA[<p>Metapackage 為 .NET Core 2.0 所提出，目的在簡化對 package 的管理。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101 </p>
<h2 id="NuGet">NuGet</h2><hr>
<ul>
<li><strong>.NET Framework</strong> : 將所有 class 包在 <code>一整包</code> .NET Framework 內</li>
<li><strong>.NET Core</strong> : 將 class 拆分成 <code>小包</code> 的 NuGet package</li>
</ul>
<blockquote>
<p>.NET Core 從以前 <code>一整包</code> framework 轉型成 <code>package-based framework</code>，也就是整個 framework 改由 package 所構成</p>
<p>簡單的說，以前 .NET Framework 是一個 framework 包含很多 DLL；而 .NET Core 是一個 DLL 就一個 package，你可以自行根據專案需求選用你用的 DLL</p>
<p>這也與目前主流 framework  思維相同，如 Angular、Laravel 都可以看到類似的設計</p>
</blockquote>
<p><strong>優點</strong></p>
<ul>
<li><strong>Package 更新速度快</strong>：若 package 有 bug，可單獨發行更新版本，不用等 framework 統一發行 patch 版本</li>
<li><strong>選擇特定 OS 與 CPU 的 package</strong> : 若有特殊需求，需使對特定 OS 與 CPU 版本最佳化的 package</li>
<li><strong>可選擇只更新部分 package 版本</strong>：若 package 有 bug，可選擇只更新某 package，而不用被 framework patch 逼得要更新其他 package</li>
<li><strong>可選擇自己需要的 package</strong> : 若你只寫 ASP.NET，其實並不需要 Windows Form、Web Form、WPF 或 UWP 的 package，只需下載 ASP.NET 相關的 package 即可</li>
</ul>
<p><strong>缺點</strong></p>
<ul>
<li><strong>不同 Package 間可能有相容性問題</strong>：由於 package 各自發佈，沒經過與其他 package 的整合測試，有可能遇到 package 彼此相衝</li>
<li><strong>Package 拆得太細，導致加入困難</strong>：.NET Core 由於 package 都最小化，隨便寫一個專案就可能要自己加入一堆 package</li>
</ul>
<p>針對這兩個缺點，.NET Core 2.0 提出了 Metapackage 概念。</p>
<h2 id="Metapackage">Metapackage</h2><hr>
<p>.NET Core 包含了以下幾個主要 Metapackage：</p>
<ul>
<li><strong>NETStandard.Library</strong>：包含 .NET Standard 所定義 API 的全部 package</li>
<li><strong>Microsoft.NETCore.App</strong>：包含 .NET Core 所需要 API 的全部 package，也包含 .NET Standard，但沒有包含全部的 .NET Standard 的 package</li>
<li><strong>Microsoft.AspNetCore.All</strong>：包含 ASP.NET 所需要 API 的全部 package，包括 <code>Microsoft.NETCore.App</code>，與其他與 ASP.NET 相關的 package。</li>
</ul>
<p>專案只要加入了 Metapackage，就相當於加了 pakcage 懶人包，會自動幫你加入其他相關的 package。</p>
<p>除此之外，Microsoft 既然發行了 Metapckage，就會確保 Metapackage 所發行的版本中，各 package 的相容性已經過測試。</p>
<blockquote>
<p>若你獨立更新 package 版本，可能會有 package 相容性問題，但若更新 Metapackage，則經過 Microsoft 測試，會挑選擇彼此相容的 package 版本</p>
</blockquote>
<h2 id="Microsoft-AspNetCore-All">Microsoft.AspNetCore.All</h2><hr>
<p>實際體驗一下有 Metapackage 與沒有 Metapackage 的差異：</p>
<h3 id="-NET_Core_1-1">.NET Core 1.1</h3><p><strong>MyMVC.csproj</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Project</span> <span class="attribute">Sdk</span>=<span class="value">"Microsoft.NET.Sdk.Web"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">TargetFramework</span>&gt;</span>netcoreapp1.1<span class="tag">&lt;/<span class="title">TargetFramework</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">PackageReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.AspNetCore"</span> <span class="attribute">Version</span>=<span class="value">"1.1.1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">PackageReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.AspNetCore.Mvc"</span> <span class="attribute">Version</span>=<span class="value">"1.1.2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">PackageReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.AspNetCore.StaticFiles"</span> <span class="attribute">Version</span>=<span class="value">"1.1.1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">PackageReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.Extensions.Logging.Debug"</span> <span class="attribute">Version</span>=<span class="value">"1.1.1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">PackageReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.VisualStudio.Web.BrowserLink"</span> <span class="attribute">Version</span>=<span class="value">"1.1.0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>預設只安裝了 4 個 package，若你用到了其他 package，需要自行加入。</p>
<h3 id="-NET_Core_2-0">.NET Core 2.0</h3><p><strong>MyMVC.csproj</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Project</span> <span class="attribute">Sdk</span>=<span class="value">"Microsoft.NET.Sdk.Web"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">TargetFramework</span>&gt;</span>netcoreapp2.0<span class="tag">&lt;/<span class="title">TargetFramework</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">PackageReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.AspNetCore.All"</span> <span class="attribute">Version</span>=<span class="value">"2.0.6"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">DotNetCliToolReference</span> <span class="attribute">Include</span>=<span class="value">"Microsoft.VisualStudio.Web.CodeGeneration.Tools"</span> <span class="attribute">Version</span>=<span class="value">"2.0.3"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>預設只安裝 <code>Microsoft.AspNetCore.All</code> Metapackage。</p>
<p><img src="/images/netcore/metapackage/tech000.png" alt="ech00"></p>
<p>但事實上 <code>Microsoft.AspNetCore.All</code> 已經包含了眾多 package。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Metapackage 並不包含實作，只定義了包含哪些 package 與版本，讓我們設計專案時不用一個 package 一個 package 地加入</li>
<li>Metapackage 也確保 package 間經過整合測試，減少 package 之間相容性問題</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/" target="_blank" rel="external">Microsoft Docs</a>, <a href="https://docs.microsoft.com/en-us/dotnet/core/packages" target="_blank" rel="external">Packages, metapackages and frameworks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Package 懶人包概念]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 FP 實現 OOP 的 Polymorphism ?]]></title>
    <link href="http://oomusou.io/fsharp/polymorphism/"/>
    <id>http://oomusou.io/fsharp/polymorphism/</id>
    <published>2018-03-21T12:23:43.000Z</published>
    <updated>2018-03-21T13:34:57.860Z</updated>
    <content type="html"><![CDATA[<p>OOP 最自豪的就是 Polymorphism (多型)，若使用 FP，該如何實現這個 OOP 的招牌菜呢？</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101<br>C# 7.2<br>F# 4.1</p>
<h2 id="Shape_Again">Shape Again</h2><hr>
<p>在眾多 OOP 書中，都會看到這個經典 Shape，這是展示 OOP 經典的 Polymorphism 與 Virtual / Override 的經典範例。</p>
<p><img src="/images/fsharp/polymorphism/poly000.svg" alt="oly00"></p>
<ul>
<li><code>Circle</code>、<code>Rectangle</code> 與 <code>Triangle</code> 都抽象化成 <code>Shape</code> 這個 abstract class</li>
<li>因為每個形狀計算面積的公式都不同，因此在 <code>Shape</code> 開 abstract method，再由 <code>Circle</code> 、 <code>Rectangle</code> 與 <code>Triangle</code> 各自實作 <code>Area()</code></li>
<li>最後將 <code>Circle</code>、<code>Rectangle</code> 與 <code>Triangle</code> 都擺進 <code>List</code>，一一的呼叫每個形狀的 <code>Area()</code>，因為 OOP 的 Polymorphism 機制，所以我們不必去判斷 class 型別，自己會執行對的 class 與 method</li>
</ul>
<p>這就是我們熟悉的 Polymorphism。</p>
<p>將分別以 C# 與 F# 實作此需求，體會一下 OOP 與 FP 的差異。</p>
<h2 id="CSharp">CSharp</h2><hr>
<p><strong>Shape.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">Area</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定義 <code>Shape</code> abstract class，其中 <code>Area()</code> 為 abstract method，因為每個形狀計算面積的公式不同，必須由子類別去實作。</p>
<p><strong>Circle.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">double</span> _radius;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="keyword">double</span> radius</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            _radius = radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">double</span> <span class="title">Area</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.14</span> * _radius * _radius;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code> 由 constructor 傳入 <code>radius</code>，並 override <code>Area()</code> 計算圓形面積。</p>
<p><strong>Rectangle.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">double</span> _width;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">double</span> _height;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="keyword">double</span> width, <span class="keyword">double</span> height</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            _width = width;</span><br><span class="line">            _height = height;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">double</span> <span class="title">Area</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _width * _height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Rectangle</code> 由 constructor 傳入 <code>width</code> 與 <code>height</code>，並 override <code>Area()</code> 計算矩形面積。</p>
<p><strong>Triangle.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Triangle</span>: <span class="title">Shape</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">double</span> _base;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">double</span> _height;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span>(<span class="params"><span class="keyword">double</span> base_, <span class="keyword">double</span> height</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            _base = base_;</span><br><span class="line">            _height = height;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">double</span> <span class="title">Area</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span> * _base * _height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Triangle</code> 由 constructor 傳入 <code>base</code> 與 <code>height</code>，並 override <code>Area()</code> 計算三角形面積。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            List&lt;Shape&gt; myList = <span class="keyword">new</span> List&lt;Shape&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> Circle(<span class="number">10.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Rectangle(<span class="number">2.0</span>, <span class="number">3.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Triangle(<span class="number">4.0</span>, <span class="number">5.0</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> shape <span class="keyword">in</span> myList)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = shape.Area();</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0:F1&#125;"</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 <code>Circle</code> 、<code>Rectangle</code> 與 <code>Triangle</code> 3 個物件都塞入 <code>List</code>，使用 <code>foreach</code> 執行每個物件的 <code>Area()</code>，不用判斷型別，就自動會執行對的物件，這就是我們熟知的 Polymorphism。</p>
<p><img src="/images/fsharp/polymorphism/poly001.png" alt="oly00"></p>
<p>各自算出各形狀的面積。</p>
<h2 id="FSharp">FSharp</h2><hr>
<p><strong>Program.fs</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> System</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Shape</span> </span>= </span><br><span class="line">    | Circle <span class="keyword">of</span> radius: float</span><br><span class="line">    | Rectangle <span class="keyword">of</span> width: float * height: float</span><br><span class="line">    | Triangle <span class="keyword">of</span> base_: float * height: float</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> area shape =</span><br><span class="line">    <span class="keyword">match</span> shape <span class="keyword">with</span> </span><br><span class="line">    | Circle radius -&gt; <span class="number">3.14</span> * radius * radius</span><br><span class="line">    | Rectangle (width, height) -&gt; width * height</span><br><span class="line">    | Triangle (base_, height) -&gt; <span class="number">0.5</span> * base_ * height</span><br><span class="line">    </span><br><span class="line"><span class="annotation">[&lt;EntryPoint&gt;]</span></span><br><span class="line"><span class="keyword">let</span> main argv =</span><br><span class="line">    <span class="keyword">let</span> circle = Circle <span class="number">10.0</span></span><br><span class="line">    <span class="keyword">let</span> rectangle = Rectangle (<span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    <span class="keyword">let</span> triangle = Triangle (<span class="number">4.0</span>, <span class="number">5.0</span>)</span><br><span class="line">    </span><br><span class="line">    [circle; rectangle; triangle]</span><br><span class="line">    |&gt; List.map area</span><br><span class="line">    |&gt; List.iter (printfn <span class="string">"%A"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="number">0</span> <span class="comment">// return an integer exit code</span></span><br></pre></td></tr></table></figure>
<p>第 3 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Shape</span> </span>= </span><br><span class="line">    | Circle <span class="keyword">of</span> radius: float</span><br><span class="line">    | Rectangle <span class="keyword">of</span> width: float * height: float</span><br><span class="line">    | Triangle <span class="keyword">of</span> base_: float * height: float</span><br></pre></td></tr></table></figure>
<p>定義 <code>Shape</code> union，包含 <code>Circle</code>、<code>Rectangle</code> 與 <code>Triangle</code> 三個 case。</p>
<p>至於三個型別的資料，則直接在 case 後面接 <code>of</code> 表示。</p>
<blockquote>
<p>我們看到 C# 必須使用 <code>abstract class</code> 與 <code>繼承</code>，才能描述 <code>Shape</code> 與 <code>Circle</code>、<code>Rectangle</code> 與 <code>Triangle</code> 之間的抽象關係，但 F# 使用 <code>union</code>只要 4 行即可，而且還是強型別</p>
</blockquote>
<p>第 8 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> area shape =</span><br><span class="line">    <span class="keyword">match</span> shape <span class="keyword">with</span> </span><br><span class="line">    | Circle radius -&gt; <span class="number">3.14</span> * radius * radius</span><br><span class="line">    | Rectangle (width, height) -&gt; width * height</span><br><span class="line">    | Triangle (base_, height) -&gt; <span class="number">0.5</span> * base_ * height</span><br></pre></td></tr></table></figure>
<p>至於 <code>Area()</code> 的多型怎麼辦 ?</p>
<p>只要使用 Pattern Matching 判斷 <code>shape</code> 的型別，各自實作其面積公式即可。</p>
<blockquote>
<p>我們看到 C# 必須使用 virtual / override 機制才能實現 Polymorphism，但 F# 使用 Pattern Matching 只要 5 行即可</p>
</blockquote>
<p>15 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> main argv =</span><br><span class="line">    <span class="keyword">let</span> circle = Circle <span class="number">10.0</span></span><br><span class="line">    <span class="keyword">let</span> rectangle = Rectangle (<span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    <span class="keyword">let</span> triangle = Triangle (<span class="number">4.0</span>, <span class="number">5.0</span>)</span><br><span class="line">    </span><br><span class="line">    [circle; rectangle; triangle]</span><br><span class="line">    |&gt; List.map area</span><br><span class="line">    |&gt; List.iter (printfn <span class="string">"%A"</span>)</span><br></pre></td></tr></table></figure>
<p>不必使用 <code>foreach</code> ，只要以 Pipeline 方式透過 <code>List.map</code> 執行每個物件的 <code>area()</code>，再以 Pipeline 方式透過 <code>List.iter</code> 將計算的結果交給 <code>printfn</code> 顯示。</p>
<blockquote>
<p>C# 雖然也可以使用 LINQ 方式，與 F# 極為類似，不過 LINQ 已經屬於 functional ，不是傳統 OOP 的 imperative </p>
</blockquote>
<p><img src="/images/fsharp/polymorphism/poly002.png" alt="oly00"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>FP 使用 <code>union</code> 即可實作出 OOP 的 <code>繼承</code> 概念</li>
<li>FP 使用 Pattern Matching 即可實作出 OOP 的 <code>virtual/override</code> 概念</li>
<li>OOP 是將 data 與 function 合一，都包在 class 內；FP 是將 data 與 function 分離，data 歸 Type，function 還是 function</li>
<li>F# 的程式碼明顯比 C# 精簡</li>
<li>並不是要比較哪個語言的優劣，只想強調 OOP 與 FP 以不同的思維，都可以實作出 Polymorphism</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 GitHub 上找到：<a href="https://github.com/oomusou/OOPPolymorphism" target="_blank" rel="external">C#</a>、<a href="https://github.com/oomusou/FPPolymorphism" target="_blank" rel="external">F#</a></p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://fsharpforfunandprofit.com/" target="_blank" rel="external">F# for fun and profit</a>, <a href="https://fsharpforfunandprofit.com/posts/key-concepts/" target="_blank" rel="external">Four Key Concepts</a></p>
]]></content>
    <summary type="html">
    <![CDATA[體會 OOP 與 FP 不同的思維]]>
    
    </summary>
    
      <category term="C#" scheme="http://oomusou.io/tags/C/"/>
    
      <category term="F#" scheme="http://oomusou.io/tags/F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 C# 實現 Strategy Pattern ?]]></title>
    <link href="http://oomusou.io/design-pattern/strategy/"/>
    <id>http://oomusou.io/design-pattern/strategy/</id>
    <published>2018-03-20T12:23:43.000Z</published>
    <updated>2018-03-22T02:17:29.995Z</updated>
    <content type="html"><![CDATA[<p>Strategy Pattern 是 OOP 中最著名的 Design Pattern，幾乎可以說是 OOP 中使用 <code>interface</code> 最經典的應用，隨著 FP 逐漸受到重視，Strategy Pattern 在實作上也有了新的面貌。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101<br>JetBrains Rider 2017.3.1<br>C# 7.2</p>
<h2 id="User_Story">User Story</h2><hr>
<p>假設你在處理訂單，訂單的折扣方式有兩種</p>
<ul>
<li>超過 1000 元，則 <code>滿千送百</code></li>
<li>不到 1000 元，則 <code>全館八折</code></li>
</ul>
<h2 id="Task">Task</h2><hr>
<p>先使用一般  <code>if else</code> 寫法完全需求，最後再分別以 OOP 與 FP 手法重構 Strategy Pattern。</p>
<h2 id="Definition">Definition</h2><hr>
<blockquote>
<p>Strategy Pattern</p>
<p>將不同演算法抽象化成相同 interface，讓高階模組與實際演算法解耦合，而彼此僅相依於 interface，進而可動態切換演算法</p>
<p>此為 OOP <code>多型</code> 最典型應用，可以一次看到 <code>單一職責原則</code>、<code>開放封閉原則</code>、<code>依賴反轉原則</code>、、<code>最小知識原則</code></p>
</blockquote>
<p><img src="/images/design-pattern/strategy/strategy016.svg" alt="trategy01"></p>
<ul>
<li><strong>Client</strong> : <code>Context</code> 的 user，實務上可能是 component 或 controller</li>
<li><strong>Context</strong> : 提供 client 呼叫的 class，實務上可能是 service</li>
<li><strong>Strategy</strong> : 定義 <code>ConcreteStrategy</code> 的 interface，只有 <code>Execute()</code>，負責要封裝的演算法邏輯</li>
<li><strong>ConcreteStrategy</strong> :  封裝演算法邏輯</li>
</ul>
<p><strong>適用時機</strong></p>
<ul>
<li>需要使用 <code>if else</code> 在 run-time 切換不同的演算法</li>
</ul>
<p><strong>優點</strong></p>
<ul>
<li>每個演算法使用一個  strategy class，符合 <code>單一職責原則</code></li>
<li>將來若有新的演算法要加入，不用修改 service，而是新增 <code>ConcreStrategy</code>，符合 <code>開放封閉原則</code></li>
<li>Client 與演算法解耦合，兩者都緊相依於 interface，符合 <code>依賴反轉原則</code></li>
<li>Client 不需知道有哪些 strategy，符合 <code>最小知識原則</code></li>
</ul>
<p><strong>缺點</strong></p>
<ul>
<li>若可選擇的演算法過多，容易造成 strategy class 數量爆炸</li>
</ul>
<p>在 GoF 的 Strategy Pattern 中，要求 Client 去 new strategy 傳入 <code>Context</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrage1());</span><br><span class="line"><span class="keyword">var</span> result = context.Request();</span><br></pre></td></tr></table></figure>
<p>但實務上，<code>Context</code> 、<code>Strategy</code>、<code>ConcreteStrategy</code> 都會在 Class Library 內，根據 <code>最小知識原則</code>，client 應該知道越少 class 越好，還要 client 知道 Class Library 有哪些 strategy class 似乎違反 <code>最小知識原則</code>。</p>
<p><strong>實務上作法</strong></p>
<p><img src="/images/design-pattern/strategy/strategy017.svg" alt="trategy01"></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Context();</span><br><span class="line"><span class="keyword">var</span> ressult = context.Request(StrategyEnum.ConcreteStrategy1);</span><br></pre></td></tr></table></figure>
<p>Client 不必負責知道 strategy，但會將 <code>enum</code> 開放給 client，client 只需將 <code>enum</code> 傳入 <code>Context</code> 即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strategy = StrategyFactory.Create(strategyEnum);</span><br><span class="line"><span class="keyword">return</span> strategy.Execute();</span><br></pre></td></tr></table></figure>
<p>至於 <code>Context.Requst()</code> 內部會透過 <code>StrategyFactory.Create()</code> 傳回適當的 strategy。</p>
<p>若真的要由 client 決定 strategy，也可以將 <code>StrategyFactory</code> 開放給 client 使用，最少 client 只要知道 <code>StrategyFactory</code> 即可，而不需知道所有 strategy class，符合 <code>最小知識原則</code> 要求。</p>
<blockquote>
<p>實務上 Strategy Pattern 會與 Factory Pattern 搭配，至於 Factory 是否要暴露給 client，可視需求決定</p>
</blockquote>
<h2 id="Architecture">Architecture</h2><hr>
<p><img src="/images/design-pattern/strategy/strategy001.png" alt="trategy00"></p>
<ul>
<li><code>OrderService</code> 相當於 <code>Context</code></li>
<li><code>StrategyFactory</code> 負責根據需求選擇 strategy</li>
<li><code>StrategyInterface</code> 定義個演算法抽象化的 method 名稱</li>
<li><code>RebateStrategy</code> 實作 <code>買千送百</code></li>
<li><code>DiscountStrategy</code> 實作 <code>全館八折</code></li>
</ul>
<h2 id="Implementation">Implementation</h2><hr>
<p><img src="/images/design-pattern/strategy/strategy002.svg" alt="trategy00"></p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> OrderLibrary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> orderService = <span class="keyword">new</span> OrderService();</span><br><span class="line">            <span class="keyword">var</span> originalPrice = <span class="number">1200</span>;</span><br><span class="line">            <span class="keyword">var</span> realPrice = orderService.GetPrice(originalPrice);</span><br><span class="line">            Console.WriteLine(<span class="string">"Original price:&#123;0&#125;, Real price:&#123;1&#125;"</span>, originalPrice, realPrice);</span><br><span class="line"></span><br><span class="line">            originalPrice = <span class="number">800</span>;</span><br><span class="line">            realPrice = orderService.GetPrice(originalPrice);</span><br><span class="line">            Console.WriteLine(<span class="string">"Original price:&#123;0&#125;, Real price:&#123;1&#125;"</span>, originalPrice, realPrice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> orderService = <span class="keyword">new</span> OrderService();</span><br><span class="line"><span class="keyword">var</span> originalPrice = <span class="number">1200</span>;</span><br><span class="line"><span class="keyword">var</span> realPrice = orderService.GetPrice(originalPrice);</span><br></pre></td></tr></table></figure>
<p>將商業邏輯都寫在 <code>OrderService</code>，當 <code>originalPrice</code> 傳入 <code>GetPrice()</code> 後，應回傳 <code>滿千送百</code> 或 <code>全館八折</code> 後的 <code>realPrice</code>。</p>
<h3 id="If_Else">If Else</h3><p><strong>OrderService</strong></p>
<p><img src="/images/design-pattern/strategy/strategy003.svg" alt="trategy00"></p>
<p><strong>OrderService.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetPrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (price &lt; <span class="number">1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> price - <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>if else</code> 很直覺的寫出程式碼，在不同 price 條件下，會有不同的計算 price 商業邏輯。</p>
<p>若計算 price 商業邏輯選擇不多，基本上使用 <code>if else</code> 無傷大雅，若選擇很多，使用 <code>if else</code> 的方式就會有以下問題 :</p>
<ul>
<li><code>GetPrice()</code> 含有太多計算 price 商業邏輯，將來不容易維護，違反 <code>單一職責原則</code></li>
<li>將來若要增加 price 商業邏輯，勢必繼續修改 <code>GetPrice()</code> 與 <code>if else</code>，將來不容易違誤，違反 <code>開放封閉原則</code></li>
</ul>
<h3 id="Unit_Test">Unit Test</h3><p>在重構之前，必須要有測試保護，才能確保沒把原本的商業邏輯重構壞，因此我們先準備好 <code>OrderService</code> 的 Unit Test，確保每個 <code>if else</code> 的 path 都有測到。</p>
<p><strong>UnitTest1.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    [TestClass]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitTest1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [TestMethod]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> 當價錢為<span class="number">1200</span>送百後應為<span class="number">1100</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Arrange</span></span><br><span class="line">            <span class="keyword">var</span> target = <span class="keyword">new</span> OrderService();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Act</span></span><br><span class="line">            <span class="keyword">var</span> actual = target.GetPrice(<span class="number">1200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assert</span></span><br><span class="line">            <span class="keyword">var</span> expected = <span class="number">1100</span>;</span><br><span class="line">            Assert.AreEqual(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [TestMethod]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> 當價錢為<span class="number">800</span>打八折後應為<span class="number">640</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Arrange</span></span><br><span class="line">            <span class="keyword">var</span> target = <span class="keyword">new</span> OrderService();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Act</span></span><br><span class="line">            <span class="keyword">var</span> actual = target.GetPrice(<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assert</span></span><br><span class="line">            <span class="keyword">var</span> expected = <span class="number">640</span>;</span><br><span class="line">            Assert.AreEqual(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由於本文重點不是在講 Unit Test，因此就不浪費篇幅解釋以上程式碼。</p>
<p><img src="/images/design-pattern/strategy/strategy000.png" alt="trategy00"></p>
<h3 id="Strategy_Pattern">Strategy Pattern</h3><p><strong>StrategyInterface</strong></p>
<p><img src="/images/design-pattern/strategy/strategy004.svg" alt="trategy00"></p>
<p><strong>StrategyInterface.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">StrategyInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">CalculatePrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定義 <code>StrategyInterface</code> 有 <code>CalculatePrice()</code>，將來其他 strategy 必須遵守此 interface。</p>
<p><strong>RebateStrategy</strong></p>
<p><img src="/images/design-pattern/strategy/strategy005.svg" alt="trategy00"></p>
<p><strong>RebateStrategy.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RebateStrategy</span> : <span class="title">StrategyInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculatePrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price - <span class="number">100.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>實作 <code>StrategyInterface</code>，實現 <code>買千送百</code> 。</p>
<p><strong>DiscountStrategy</strong></p>
<p><img src="/images/design-pattern/strategy/strategy006.svg" alt="trategy00"></p>
<p><strong>DiscountStrategy.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiscountStrategy</span> : <span class="title">StrategyInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculatePrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price * <span class="number">0.80</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實作 <code>StrategyInterface</code>，實現 <code>全館八折</code> 。</p>
<p><strong>StrategyFactory</strong></p>
<p><img src="/images/design-pattern/strategy/strategy007.svg" alt="trategy00"></p>
<p><strong>StrategyFactory.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StrategyFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StrategyInterface <span class="title">Create</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price &lt; <span class="number">1000</span> ? (StrategyInterface) <span class="keyword">new</span> DiscountStrategy() : <span class="keyword">new</span> RebateStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前有 <code>RebateStrategy</code> 與 <code>DiscountStrategy</code> 兩個 strategy，到底 <code>OrderService.GetPrice()</code> 該選擇拿個 strategy 呢 ?</p>
<p>特別新增 <code>StrategyFactory</code> 專責負責根據不同的 price，選擇不同的 strategy。</p>
<blockquote>
<p>Strategy Pattern 實務上都會搭配 Factory Pattern，由 <code>factory</code>  根據條件選擇適當的 strategy</p>
</blockquote>
<p><strong>OrderService</strong></p>
<p><img src="/images/design-pattern/strategy/strategy008.svg" alt="trategy00"></p>
<p><strong>OrderService.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetPrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> StrategyFactory.Create(price).calculatePrice(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OrderService</code> 可輕易的根據 <code>Create(price)</code> 回傳的 strategy，呼叫 <code>calculatePrice()</code>。</p>
<h3 id="Delegate">Delegate</h3><p>從 Strategy Pattern，我們看到了 OOP 幾個缺點：</p>
<ul>
<li>原本簡單的 <code>if ... else</code> 被拆成很多檔案，導致 class 爆炸</li>
<li><code>interface</code> 雖然有制定 spec 與 compiler 編譯檢查的優點，但是只有一個 method 的 interface，是否有有開 <code>interface</code> 的需要？</li>
</ul>
<p>雖然 <code>StrategyInterface</code> 定義了 <code>CalculatePrice()</code>，但整個 <code>interface</code> 只有一個 method，顯然使用 <code>interface</code> 有殺雞用牛刀之嫌，此時可將 <code>interface</code> 退化成 <code>delegate</code>。</p>
<p><img src="/images/design-pattern/strategy/strategy009.svg" alt="trategy00"></p>
<p><strong>CalculatePriceDelegate</strong></p>
<p><img src="/images/design-pattern/strategy/strategy010.svg" alt="trategy01"></p>
<p><strong>CalculatePriceDelegate.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">double</span> <span class="title">CalculatePriceDelegate</span>(<span class="params"><span class="keyword">double</span> price</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定義 <code>CalculatePriceDelegate</code> delegate，其 signature 為 <code>double =&gt; double</code>，也就是 input 為 <code>double</code>，return 為 <code>double</code>。</p>
<blockquote>
<p>Q : Delegate 到底是什麼 ?</p>
</blockquote>
<p>Delegate 在 C# 1.0 就已經提出，C 對於 function，只提供了一個 function pointer ，C# 想為 function pointer 提供 type safety 功能，因此提出了 <code>delegate</code>。</p>
<p>簡單的說，<code>delegate</code> 就是 function 的 named type，將 function 取一個 <code>有名稱</code> 的 <code>型別</code>，之後就可以用 delegate 所定義的型別當作 function 的 spec，若 function 不符合 <code>delegate</code> 的 signature，則 compiler 會報錯，達到 type safety 目標。</p>
<p><code>delegate</code> 是 C# 支援 FP 的濫觴，所有的 C# 的 Functional 支援，都是從 <code>delegate</code> 開始。</p>
<blockquote>
<p>實務上 Strategy Pattern 通常只有一個 method，所以就很適合將 interface 退化成 delegate</p>
</blockquote>
<p><strong>PriceStrategy</strong></p>
<p><img src="/images/design-pattern/strategy/strategy011.svg" alt="trategy01"></p>
<p><strong>PriceStrategy.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PriceStrategy</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">CalculateRebatePrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price - <span class="number">100.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">CalculateDiscountPrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將每個 strategy 以 function 表示，此時改用 static function 即可。</p>
<p>一般來說，OOP 都建議不要使用 <code>static</code>，但這裡是例外，此時是將 class 當成 module 看待，<code>static function</code> 是當成 FP 的 <code>pure function</code> 使用，也就是這種 class 將沒有 field，也不使用 OOP 的 <code>繼承</code> 與 <code>組合</code>。</p>
<p>如此我們就 Strategy Pattern 的 strategy class 爆炸問題解決，無論幾個 strategy，都永遠只有一個 strategy class。</p>
<blockquote>
<p>OOP 將所有的 strategy 都拆成一個 class，很容易因為 strategy 過多，而造成 class 爆炸，這也是 OOP 一直被人詬病的問題之一，FP 將 strategy class 退化成 strategy function，並將所有 strategy 放在同一個 class 內，避免 class 滿天飛</p>
</blockquote>
<p><strong>StrategyFactory</strong></p>
<p><img src="/images/design-pattern/strategy/strategy012.svg" alt="trategy01"></p>
<p><strong>StrategyFactory.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StrategyFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CalculatePriceDelegate <span class="title">Create</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price &lt; <span class="number">1000</span></span><br><span class="line">                ? (CalculatePriceDelegate) PriceStrategy.CalculateDiscountPrice</span><br><span class="line">                : PriceStrategy.CalculateRebatePrice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StrategyFactory</code> 的 <code>Create()</code> 從原本回傳 strategy object 改成回傳 strategy function，也就是所有的 function 都必須符合 <code>CalculatePriceDelegate</code> delegate 型別，若違反 <code>delegate</code> ，將會 compiler 錯誤。</p>
<blockquote>
<p>簡單的說，Delegate 就是 function 的 interface 或 function 的 type，這樣 compiler 才能幫我們檢查</p>
</blockquote>
<h3 id="Func">Func</h3><p>雖然 <code>CalculatePriceDelegate</code> 定義 function 的 spec 的理念很不錯，若 <code>delegate</code> 只使用一遍，真的需要開一個檔案建立 <code>delegate</code> 嗎 ?</p>
<p><strong>StrategyFactory</strong></p>
<p><img src="/images/design-pattern/strategy/strategy012.svg" alt="trategy01"></p>
<p><strong>StrategyFactory.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StrategyFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Func&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; Create(<span class="keyword">double</span> price)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> price &lt; <span class="number">1000</span></span><br><span class="line">                ? (Func&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;) PriceStrategy.CalculateDiscountPrice</span><br><span class="line">                : PriceStrategy.CalculateRebatePrice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 <code>delegate</code> 退化成 <code>Func&lt;T&gt;</code> ，其中泛型第一個參數為 input 型別，最後一個參數為 return 型別，也就是 <code>Func&lt;double, double&gt;</code> 其實與 <code>delegate double CalculatePriceDelegate(double price);</code> 意義完全相同，只是 <code>Func&lt;T&gt;</code> 沒有型別名稱，而 <code>delegate</code> 有型別名稱而已。</p>
<p>如此我們就將 <code>CalculatePriceDelegate</code> 消滅了。</p>
<blockquote>
<p>Q : Delegate vs. Func<t> vs. Action<t> vs. Predicate<t></t></t></t></p>
</blockquote>
<ul>
<li><strong>Delegate</strong> : C# 1.0，可為 function 定義型別，並且定義型別名稱</li>
<li><strong>Func<t></t></strong> : C# 3.0，可為 function 定義型別，但不用定應型別名稱，適用於有 return 值的 funciton</li>
<li><strong>Action<t></t></strong> : C# 3.0，可為 function 定義型別，但不用定義型別名稱，適用無 return 值 (void) 的 function</li>
<li><strong>Predicate<t></t></strong> : C# 3.0，可為 function 定義型別，但不用定義型別名稱，適用無 return bool 的 function</li>
</ul>
<blockquote>
<p>若 function type 需要重複使用，則建議使用 <code>delegate</code>，並取一個型別名稱</p>
<p>若 function type 只用一次，不需要型別名稱，則建議使用 <code>Func&lt;T&gt;</code> 、 <code>Action&lt;T&gt;</code> 或 <code>Predicate&lt;T&gt;</code>，可視為 anonymous function type 或 unnamed funciton type</p>
</blockquote>
<h3 id="Lambda">Lambda</h3><p><code>StrategyFactory</code> 回傳 strategy function 的理念雖然不錯，若 <code>StrategyFactory</code> 在整個 project 只使用一次而已，是否真的要另外開一個 class ?</p>
<p><img src="/images/design-pattern/strategy/strategy014.svg" alt="trategy01"></p>
<p><strong>OrderService</strong></p>
<p><img src="/images/design-pattern/strategy/strategy015.svg" alt="trategy01"></p>
<p><strong>OrderService.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetPrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Func&lt;<span class="keyword">double</span>, Func&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;&gt; CreateStrategy =</span><br><span class="line">                (orignalPrice) =&gt; price &gt; <span class="number">1000</span></span><br><span class="line">                    ? (Func&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;) PriceStrategy.CalculateRebatePrice</span><br><span class="line">                    : PriceStrategy.CalculateRebatePrice;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> strategy = CreateStrategy(price);</span><br><span class="line">            <span class="keyword">return</span> strategy(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C# 3.0 提出了 Lambda，讓我們可以直接在 function 定義新的 function，而不一定要將 function 建立在 class 內。</p>
<p>直接在 <code>GetPrice()</code> 內定義 <code>CreateStrategy()</code>。</p>
<p><code>Func&lt;&gt;</code> 第一個參數 <code>double</code> 為 <code>CreateStrategy()</code> 的 input 參數型別。</p>
<p>因為 <code>CreateStrategy()</code>  是回傳 <code>Func&lt;double, double&gt;</code> 的 funciton，故第 2 個參數為 <code>Func&lt;double, double&gt;</code>。</p>
<p>如此我們就將 <code>StrategyFactory</code> class 消滅了。</p>
<h3 id="Local_Function">Local Function</h3><p><strong>OrderService</strong></p>
<p><img src="/images/design-pattern/strategy/strategy015.svg" alt="trategy01"></p>
<p><strong>OrderService.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OrderLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetPrice</span>(<span class="params"><span class="keyword">double</span> price</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Func&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; CreateStrategy(<span class="keyword">double</span> originPrice) =&gt; </span><br><span class="line">                originPrice &gt; <span class="number">1000</span></span><br><span class="line">                ? (Func&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;) PriceStrategy.CalculateRebatePrice</span><br><span class="line">                : PriceStrategy.CalculateDiscountPrice;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> strategy = CreateStrategy(price); </span><br><span class="line">            <span class="keyword">return</span> strategy(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda 雖然讓我們可以在 function 內定義 funtion，但 <code>Func&lt;double, Func&lt;double, double&gt;&gt;</code> 寫法有點恐怖。</p>
<p>C# 7.0 提出了 Local Function，類似宣告 function 的寫法，讓 function 的定義更人性化。</p>
<blockquote>
<p>實務上建議使用 Local Function 取代 Lambda</p>
</blockquote>
<h2 id="Summary">Summary</h2><hr>
<p>以 SOLID 角度重新審視經過 FP 二次重構後的 Strategy Pattern：</p>
<ul>
<li><strong>單一職責原則</strong>：將所有的 strategy 統一整理在 <code>PriceStrategy</code>，符合 SRP</li>
<li><strong>開放封閉原則</strong>：將來若有新的 strategy，只要統一加在 <code>PriceStrategy</code> 即可，符合 OCP</li>
<li><strong>里氏替換原則</strong>：因為沒用到繼承，所以沒有違反 LSP 問題</li>
<li><strong>最小知識原則</strong>：strategy 並沒有暴露到 client，符合 LKP</li>
<li><strong>介面隔離原則</strong>：因為從 <code>interface</code> 退化成 <code>delegate</code>，FP 天生符合 ISP</li>
<li><strong>依賴反轉原則</strong>：service 與 strategy 之間的耦合僅限於 <code>delegate</code> 與 <code>Func&lt;T&gt;</code>，而不是直接耦合與特定 function，符合 DIP</li>
</ul>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Strategy Pattern、State Pattern 與 Chain of Responsibility 都是在解決 <code>if else</code> 問題，但 intention 不太一樣</li>
<li>FP 的出現，讓 Design Pattern 的實踐方式，不再只有 OOP 一途，可視實際需求決定該使用 OOP 或 FP</li>
<li>OOP 讓我們以 <code>抽象設計</code> 的角度看系統，但 FP 讓我們以 <code>簡化設計</code> 的角度看系統，實務上建議以 OOP 做第一階段的重構，再輔以 FP 做第二階段的重構，可解決 OOP 容易 Over Design 的問題</li>
<li>C# 1.0 主要是 OOP，C# 2.0 主要是泛型，C# 3.0 之後主要是 FP 部分，如 Lambda、LINQ，C# 也是在 3.0 開始與 Java 分道揚鑣，朝向 OOP + FP 雙 hybrid 語言目標邁進，尤其 C# 7.0 非常明顯，如 Tuple、Descontruction、Pattern Matching、Local Function … 都是 FP 語言很基本的機制</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/Core2OrderStrategy" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[使用 FP 將有不同的實現方式]]>
    
    </summary>
    
      <category term="C#" scheme="http://oomusou.io/tags/C/"/>
    
      <category term="Design Pattern" scheme="http://oomusou.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探討 TypeScript 之 Generics]]></title>
    <link href="http://oomusou.io/typescript/generics/"/>
    <id>http://oomusou.io/typescript/generics/</id>
    <published>2018-03-18T12:23:43.000Z</published>
    <updated>2018-03-21T06:17:00.095Z</updated>
    <content type="html"><![CDATA[<p><code>泛型</code> 是物件導向 <code>多型</code> 的延伸技術，多型是以 interface 為基礎，在 <code>執行時期</code> 決定適當型別；而泛型則是以 type parameter 為基礎，在 <code>編譯時期</code> 決定適當型別。</p>
<p>泛型也是 TypeScript 的一大特色，預計 ECMAScript 將來也不會採用泛型。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>TypeScript 2.5</p>
<h2 id="泛型概論">泛型概論</h2><hr>
<p>OOP 就是 <code>繼承</code>、<code>封裝</code> 與 <code>多型</code>，為了支援更多型別，OOP 教我們使用 <code>多型</code>，白話就是抽 <code>interface</code>，但實務上會發現，有很多物件之間根本扯不上什麼關係，很難抽 interface，此時就必須使用 <code>泛型</code>。</p>
<p>泛型並不是什麼新觀念，早在 C++ 就有泛型，後來 C# 2.0 也支援泛型，Java 最後也跟進，而 TypeScript 讓 JavaScript 也能使用泛型。</p>
<blockquote>
<p>多型 : 以 interface 為基礎，將不同型別的物件，抽象化成 interface 型別的物件，但實際上是 <code>多</code> 種 <code>型</code>別的物件。(C++、C#、Java、PHP)</p>
<p>泛型 : 不用抽 interface，以 type parameter 為基礎，透過傳遞型別參數，將各物件抽象化成 <code>T</code> 型別物件，但實際上是 <code>泛</code> 指各種 <code>型</code> 別物件。(C++、C#、Java、TypeScript)</p>
<p>無型 : 因為 <code>無型</code>別，因此可以支援各種型別，但也因為無型別，所以喪失 intellisense 與編譯檢查型別的功能。(JavaScript、PHP)</p>
</blockquote>
<h2 id="TypeScript_Generics">TypeScript Generics</h2><hr>
<p>TypeScript 一共提供 3 種 generics : </p>
<ul>
<li>Generic Function</li>
<li>Generic Interface</li>
<li>Generic Class</li>
</ul>
<h2 id="Generic_Function">Generic Function</h2><hr>
<h3 id="內建型別">內建型別</h3><p>Identity Function</p>
<blockquote>
<p>無論輸入什麼，就輸出什麼</p>
</blockquote>
<p>白話 : 輸入數值就會傳數值；輸入物件就回傳物件；輸入函式就回傳函式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很簡單的 identity function，為了 <code>number</code> 與 <code>string</code> 就開了 2 個 function，傳入 <code>物件</code> 與傳入 <code>函式</code> 的部分還沒有實作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>any</code> 就類似 PHP 不使用型別一樣，就表示任何型別都可以當 parameter，return type 也可以是任何型別。</p>
<p>但這種寫法有 <code>2</code> 個缺點 :</p>
<ul>
<li>Parameter 與 return type 都為 <code>any</code>，但不代表是同一個 <code>any</code>，可能 parameter 是 <code>string</code>，而 return type 是 <code>number</code></li>
<li><code>echo()</code> 回傳後的物件喪失了原本的型別，無法得知原本是 <code>number</code> 還是 <code>string</code></li>
</ul>
<blockquote>
<p><code>any</code> 算是某種 <code>泛型</code> 味道，但算是 <code>無型</code>，並不算是個完美的解決方案，它會喪失原本變數的型別。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>echo()</code> 為了支援各種型別，引入泛型觀念，在 function 名稱後加入 <code>&lt;&gt;</code>，此為 type parameter，專門負責傳入 <code>型別參數</code>，有別於 function 的 <code>()</code> ，用來傳遞數值、物件與函式。</p>
<p>因為把型別當成參數後，<code>echo()</code> 就可以支援各種型別，只要呼叫 <code>echo()</code> 多傳入 <code>型別參數</code> 即可，這樣也可確保 parameter 型別為 <code>T</code>，且 return type 為 <code>T</code>。</p>
<blockquote>
<p>並不一定要用 <code>T</code>，因為 <code>T</code>ype，所以慣用 <code>T</code>，第二個泛型常用 <code>U</code>，以此類推。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = echo&lt;<span class="built_in">string</span>&gt;(<span class="string">'Sam'</span>);</span><br></pre></td></tr></table></figure>
<p>呼叫 <code>echo()</code> 時多帶 <code>&lt;string&gt;</code>，就能確保 <code>output</code> 也是 <code>string</code> 型別，而 <code>&lt;&gt;</code> 可以傳進任何型別，因此稱為 <code>泛型</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = echo(<span class="string">'Sam'</span>);</span><br></pre></td></tr></table></figure>
<p>因為 <code>arg: T</code>，TypeScript 會自動根據 <code>Sam</code> 推導出 <code>T</code> 應該為 <code>string</code>。</p>
<p>同理 </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = echo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>TypeScript 也會自動根據 <code>1</code> 推導出 <code>T</code> 為 <code>number</code>。</p>
<blockquote>
<p>若 <code>T</code> 有在 parameter 裡，TypeScript 會自動根據 argument 推導出 T 的型別，因此使用上不用特別傳入型別參數；若 <code>T</code> 不在 parameter 上，就必須明確在 <code>&lt;&gt;</code> 傳入型別參數。</p>
<p>Generic function 對於使用上並沒有任何負擔，且不會喪失原本變數的型別資訊，是比 <code>any</code> 更好的 <code>泛型</code> 解決方案。</p>
</blockquote>
<h3 id="陣列">陣列</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若希望 parameter 為陣列，當然也可以繼續用 <code>T</code>，不過使用 <code>T</code> 之後，TypeScript 將認為此 parameter 可能為任何型別，若你去使用陣列的 property，如 <code>length</code>，將沒有 intellisense 使用，且編譯也會報錯。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function echo&lt;T&gt;(arg: T[]): T[] &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因為 <code>arg</code> 為 <code>T[]</code>，會視為 <code>Array</code>，因此 intellisense 有 <code>length</code>，且編譯也會通過。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    consoloe.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Array&lt;T&gt;</code> 寫法亦可。</p>
<h2 id="Generic_Interface">Generic Interface</h2><hr>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEcho: &lt;T&gt;(arg: T) =&gt; T = echo;</span><br></pre></td></tr></table></figure>
<p>若要描述 <code>echo&lt;T&gt;()</code> 的型別，使用 <code>&lt;T&gt;(arg: T) =&gt;T</code>，比較特別的是 function 的 return type 改用 <code>=&gt;</code>，而非 <code>:</code>，因為 <code>myEcho</code> 的型別已經用了 <code>:</code>，因此 function 的 return type 改用 arrow function 的 <code>=&gt;</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEcho: &#123;&lt;T&gt;(arg: T): T&#125; = echo;</span><br></pre></td></tr></table></figure>
<p>也可使用 object literal 寫法，因為在 <code>{}</code> 內，此時 return type 可用 <code>:</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> IEcho </span>&#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEcho: IEcho = echo;</span><br></pre></td></tr></table></figure>
<p>也可將 <code>echo&lt;T&gt;()</code> 型別的 object literal 寫法，改用 function interface 表示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> IEcho&lt;T&gt; </span>&#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEcho&lt;<span class="built_in">string</span>&gt;: IEcho = echo;</span><br></pre></td></tr></table></figure>
<p><code>&lt;T&gt;(arg: T): T;</code> 的寫法，<code>T</code> 僅作用於 method，若我們想將 <code>T</code> 作用於整個 interface，會移到 interface 名稱後面。</p>
<blockquote>
<p>Q : 使用 generic interface 時，<code>&lt;T&gt;</code> 該使用在 interface 還是 function ?</p>
</blockquote>
<ul>
<li>若你想由 function 來推倒出 interface 的 <code>T</code>，則將 <code>T</code> 放在 function</li>
<li>若你想由 interface 來決定 <code>T</code>，function 必須遵守，則將 <code>T</code> 放在 interface</li>
<li>各有各的優點，要依實際狀況決定該用哪種方式</li>
</ul>
<h2 id="Generic_Class">Generic Class</h2><hr>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<p><code>T</code> 定義了 class 內的 property 與 method signature 的型別。</p>
<blockquote>
<p>Generic class 的 <code>T</code> 只能用在 object level，不能用在 class level 的 static 部分。<br>只有 generic function，generic interface 與 generic class，並沒有 generic enums。<br>只有 generic function 可以由 parameter 自動推導出 <code>&lt;T&gt;</code>，generic interface 與 generic class 則必須明確傳入 <code>&lt;T&gt;</code>。</p>
</blockquote>
<h2 id="Generic_Constraint">Generic Constraint</h2><hr>
<h3 id="Extends_Interface">Extends Interface</h3><p>在之前的例子，因為我們需要 <code>arg.length</code> ，因而改用 <code>T[]</code>，若我們要得不是陣列的 <code>length</code> property，而是傳入的 parameter 必須要有 <code>length</code> property 呢 ?</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> Lengthwise </span>&#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> Lengthwise </span>&#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 object interface，定義 <code>length</code> property。</p>
<p>第 5 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span></span></span><br></pre></td></tr></table></figure>
<p>一樣使用 <code>&lt;T&gt;</code>，但必須 <code>T extends Lengthwise</code>，表示 <code>T</code> 不再是任意型別，而必須是有實現 <code>Lengthwise</code> interface 的型別，否則 TypeScript 會編譯錯誤。</p>
<blockquote>
<p>Q : <code>Lengthwise</code> 是 interface，<code>T</code> 應該是要 <code>implements</code> interface，怎麼是 <code>extends</code> interface 呢 ?</p>
</blockquote>
<p><code>T</code> 是個 type，TypeScript 也允許 interface 繼承 interface，相當於 property 的組合，因此 <code>T extends Lengthwise</code> 後，<code>T</code> 會多了 <code>length</code> property，因此 <code>arg</code> 一定要有 <code>length</code> property 的才會通過 TypeScript 編譯。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn't have a .length property</span></span><br></pre></td></tr></table></figure>
<p>用了 generic constraint 之後，傳入 <code>3</code> 會編譯錯誤，因為 <code>number</code> 型別沒有 <code>length</code> property。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><code>({length: 10, value: 3}</code> 有 <code>lenght</code> property，有符合 <code>Lengthwise</code> 的要求，TypeScript 編譯通過。 </p>
<blockquote>
<p>之前講 interface 時，談到 object literal 當  argument 時，會啟動 excess property checks，也就是 strong typing 檢查，但用在 generic constraint 時，TypeScript 卻只採用 duck typing 檢查。</p>
<p>Q : 為什麼不直接用 interface，卻要用 generic constraint ?</p>
</blockquote>
<p>一開始我也覺得 interface 與 generic constraint 是一樣的，但仔細想想還是不同，若用 interface 改寫 :</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> Lengthwise </span>&#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>(<span class="params">arg: Lengthwise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Parameter 部分沒問題，型別使用 <code>Lengthwise</code> interface 即可。</p>
<p>但 return type 就尷尬了，無法只傳回 <code>Lengthwise</code> interface。</p>
<p>所以還是得靠 <code>&lt;T&gt;</code> 搭配 generic constraint 才會功德圓滿。</p>
<blockquote>
<p>若 return type 與 <code>T</code> 無關時，的確使用 interface 即可。</p>
</blockquote>
<h3 id="Extends_KeyOf">Extends KeyOf</h3><p>Generic constraint 不見的只能根據既有的 interface，還能根據其他 type parameter。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">"a"</span>); <span class="comment">// okay</span></span><br><span class="line">getProperty(x, <span class="string">"m"</span>); <span class="comment">// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span></span><br></pre></td></tr></table></figure>
<p>實務上我們可能希望 function 的第 1 個參數為 object，第 2 個參數為 object 的 key，希望傳回 object 的 value，但要如何確保輸入的 key 一定是 object 的 key 呢 ?</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>T</code> : 傳入物件的泛型。</p>
<p><code>keyof T</code> : 物件的 key。</p>
<p><code>K extends keyof T</code> : <code>K</code> 須為 <code>T</code> 的 key。</p>
<blockquote>
<p>藉由 <code>extends keyof</code> 語法，若輸入的值不是 object 的 key，TypeScript  將會編譯錯誤。</p>
</blockquote>
<h3 id="new():_T">new(): T</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function create&lt;T&gt;(c: new() =&gt; T): T &#123;</span><br><span class="line">    return new c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Factory method / constructor function 目的在於取代 new 建立物件，因此我們會需要 paramter 傳入 constructor，若想要以泛型描述 constructor，可用 <code>new() =&gt;T</code> 加以描述。</p>
<h2 id="實務上的應用">實務上的應用</h2><hr>
<p>剛剛介紹了泛型的語法，現在介紹實務上該如何使用泛型。</p>
<h3 id="Service_處理不同_Model">Service 處理不同 Model</h3><p>實務上常會遇到 service 的不同 method 處理不同 model，事後卻發現其演算法完全相同，因此想抽成同一個 method 實現 DRY，卻發現因為 model 型別不同而無法 extract method。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToSMS</span><span class="params">(SMSMessage <span class="variable">$smsMessage</span>)</span>: <span class="title">SMSMessage</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable">$smsMessage</span>-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">        ...    </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$smsMessage</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToLine</span><span class="params">(LineMessage <span class="variable">$lineMessage</span>)</span>: <span class="title">LineMessage</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable">$lineMessage</span>-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">        ...  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$lineMessage</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 3 行<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToSMS</span><span class="params">(SMSMessage <span class="variable">$smsMessage</span>)</span>: <span class="title">SMSMessage</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable">$smsMessage</span>-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$smsMessage</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>傳入 <code>SMSMessage</code> model 進 <code>addFromToSMS()</code>，主要目的是將 <code>Senao</code> 指定給 <code>$smsMessag-&gt;from</code> 。</p>
<blockquote>
<p><code>Senao</code> 也可能是由演算法算出的產物，但最終都要指定給 <code>from</code> property，並回傳 <code>SMSMessage</code> model。</p>
</blockquote>
<p>第 10 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToLine</span>(<span class="params">LineMessage $lineMessage</span>): <span class="title">LineMessage</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	$lineMessage-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> $lineMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>傳入 <code>LineMessage</code> model 進 <code>addFromToLine()</code> ，主要目的是將 <code>Senao</code> 指定給 <code>$lineMessage</code>。</p>
<blockquote>
<p><code>Senao</code> 也可能是由演算法算出的產物，但最終都要指定給 <code>from</code> property，並回傳 <code>LineMessage</code> model。</p>
</blockquote>
<p>我們可以發現，<code>addFromToSMS()</code> 與 <code>addFromToLine()</code> 基本上演算法相同，要解決的問題也相同，只因為傳入 parameter 的型別與傳回的 return type 不同，因此被逼要用兩個 method 處理。</p>
<p>因為演算法相同，我們希望只使用一個 method 就能解決。</p>
<p>在 PHP，可能有 <code>2</code> 種解法 :</p>
<ul>
<li>放棄 Type Hint</li>
<li>將共用部分抽 Interface</li>
</ul>
<p><strong>放棄 Type Hint</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToMessage</span><span class="params">(<span class="variable">$smsMessage</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable">$smsMessage</span>-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$smsMessage</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然因為 type hint 而拆成兩個 method，那乾脆回歸 PHP 最原始寫法 : <code>完全放棄 type hint</code>，這樣 <code>SMSMessage</code> 與 <code>LineMessage</code> 兩種型別的物件都可以傳入。</p>
<blockquote>
<p>這也是最多人在 PHP 處理的方式。</p>
</blockquote>
<p>但這種方式也有幾個缺點 :</p>
<ul>
<li>因為 <code>$smsMessage</code> 沒有任何型別描述，因此 <code>$smsMessage</code> 也喪失了 intellisense</li>
<li>維護程式的人無法得知 <code>$smsMessage</code> 是什麼型別，只能 trace code 根據前後文去得知其型別</li>
<li>沒有描述 return type，因此接受 <code>addFromToMessage()</code> 的物件也喪失 intellisense</li>
</ul>
<p><strong>將共用部分抽 Interface</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessageFrom</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> string*/</span></span><br><span class="line">    <span class="keyword">public</span> from;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSMessage</span> <span class="keyword">implements</span> <span class="title">IMessageFrom</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">public</span> from;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineMessage</span> <span class="keyword">implements</span> <span class="title">IMessageFrom</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">public</span> from;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToMessage</span><span class="params">(IMessageFrom <span class="variable">$smsMessage</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable">$smsMessage</span>-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$smsMessage</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessageFrom</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> string*/</span></span><br><span class="line">    <span class="keyword">public</span> from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然 <code>from</code> 為 <code>SMSMessage</code> 與  <code>LineMessage</code> 共同的部分，我們可以將 <code>from</code> 抽成 <code>IMessageFrom</code>。</p>
<p>第 7 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSMessage</span> <span class="keyword">implements</span> <span class="title">IMessageFrom</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">public</span> from;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineMessage</span> <span class="keyword">implements</span> <span class="title">IMessageFrom</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">public</span> from;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然後要求 <code>SMSMessage</code> 與 <code>LineMessage</code> 去 implement <code>IMessageFrom</code>。</p>
<p>23 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addFromToMessage</span><span class="params">(IMessageFrom <span class="variable">$smsMessage</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="variable">$smsMessage</span>-&gt;from = <span class="string">'Senao'</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$smsMessage</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣 <code>addFromToMessage()</code> 的 parameter 就可以加上 <code>IMessageFrom</code> type hint。</p>
<p>這種寫法解決了之前的 2 個問題 :</p>
<ul>
<li>因為 <code>$smsMessage</code> 有了型別描述，因此 <code>$smsMessage</code> 有 intellisense</li>
<li>維護程式的人可以得知 <code>$smsMessage</code> 是什麼型別，不需要 trace code</li>
</ul>
<p>但仍有 1 個問題沒解決 :</p>
<ul>
<li>原本 <code>addFromToSMS()</code> 的回傳型別為 <code>SMSMessage</code>，<code>addFromToLine()</code> 回傳型別為 <code>LineMessage</code>，但現在 return type 仍然無法描述，因此接受 <code>addFromToMessage()</code> 的物件仍然喪失 intellisense</li>
</ul>
<blockquote>
<p>若有了 generics，就可以完美解決這個問題</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> IMessageFrom </span>&#123;</span><br><span class="line">    from: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> NotificationService &#123;</span><br><span class="line">    addFromToMessage&lt;T extends IMessageFrom&gt;(smsMessage: T): T &#123;</span><br><span class="line">        ...</span><br><span class="line">        smsMessage.from = <span class="string">'Senao'</span>;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> smsMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="interface"><span class="keyword">interface</span> IMessageFrom </span>&#123;</span><br><span class="line">  from: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一樣使用 interface 描述要有 <code>from</code> property。</p>
<p>第 6 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addFromToMessage&lt;T extends IMessageFrom&gt;(smsMessage: T): T &#123;</span><br><span class="line">    ...</span><br><span class="line">    smsMessage.from = <span class="string">'Senao'</span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> smsMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addFromToMessage&lt;T&gt;(smsMessage: T): T</span><br></pre></td></tr></table></figure>
<p><code>smsMessage</code> 的型別改用 <code>T</code> 表示，且 return type 也為 <code>T</code>。</p>
<p>這解決了之前 2 種方式的 <code>addFromToMessage()</code> 無法描述 return type 的問題，目前 return type 為 <code>T</code>，與傳入 parameter 的型別相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addFromToMessage&lt;T extends IMessageFrom&gt;(smsMessage: T): T</span><br></pre></td></tr></table></figure>
<p>但 <code>T</code> 為任何型別，並無法保證 <code>from</code> property 一定存在，因此在 type parameter 加上 <code>&lt;T extends IMessageFrom&gt;</code> (Generic Constraint)，確保 <code>T</code> 一定要有 <code>IMessageFrom</code> interface，否則 TypeScript 會編譯失敗。</p>
<p>如此 return type 與 interface 問題皆可解決。</p>
<blockquote>
<p><code>T extends interface</code> 讓我們實現 <code>有限制的泛型</code>，<code>T</code> 不再是任意型別，而是要有實現 interface 的特定型別。</p>
</blockquote>
<h3 id="Array_處理不同_Model">Array 處理不同 Model</h3><p>實務上會使用 array 放不同 model，但缺發現 method 回傳後，已經喪失原本 array 內物件的型別。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sortMessages</span><span class="params">(array <span class="variable">$messages</span>)</span>: <span class="title">array</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sortMessages()</code> 負責對 model 陣列做排序，由於 <code>$messages</code> 只宣告為 <code>array</code> 型別，因此使用上</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sortMessages(<span class="variable">$smsMessages</span>);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sortMessages(<span class="variable">$lineMessages</span>);</span><br></pre></td></tr></table></figure>
<p>皆可以傳入。</p>
<p>儘管在 array 內處理不同 model，但最少都在同一個 <code>sortMessages()</code> 裡面，已經有泛型的味道。</p>
<p>但這樣寫有 <code>2</code> 個問題 :</p>
<ul>
<li><code>array</code> 是一個概括性的型別，我們無法得知 array 內放的是 <code>SMSMessage</code> 或是 <code>LineMessage</code> 型別。</li>
<li>回傳的 <code>array</code> 也是個概括型別，接受 <code>sortMessages()</code> 的回傳物件，只能知道是個 array，但不知道內部是什麼物件，如 <code>foreach()</code> 時，就無法對內部物件做 intellisense。</li>
</ul>
<p><code>1</code> 的問題還好，因為 <code>sortMessages()</code> 主要是針對 array 做排序，因此不會使用到 array 內部物件的 intellisense，但 <code>2</code> 的問題比較嚴重。</p>
<blockquote>
<p>若有了 generics，就可以完美解決這個問題</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NotificationService &#123;</span><br><span class="line">    sortMessages&lt;T&gt;(messages: T[]): T[] &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T</code> 代表任意型別，<code>T[]</code> 為任意型別的陣列，且 return type <code>T[]</code> 亦為任意型別的陣列。</p>
<p>這種寫法解決了原本的問題 :</p>
<ul>
<li><code>messages</code> 不再只是概括性的 <code>array</code> 型別，而是明確的 <code>T[]</code> 型別，其中 <code>T</code> 就是傳入的 model 型別。</li>
<li>回傳的也不再是概括的 <code>array</code> 型別，而是明確的 <code>T[]</code>，<code>sortMessages()</code> 的接受者可以明確地得知其型別為 <code>T</code>，TypeScript 編譯器會自動將 <code>T</code> 以 model 的型別取代，因此 <code>foreach</code> 可順利抓到物件的型別。</li>
</ul>
<blockquote>
<p>對於 array 這種 container 類型的型別，我們不必只是宣告空洞的 <code>array</code> 型別而已，而是真正以 array 的內容來宣告型別。</p>
</blockquote>
<h3 id="Repository_處理不同_Model">Repository 處理不同 Model</h3><p>Repository 負責處理資料庫邏輯，實務上會發現有些 method 在所有的 repository 都會出現，因此會想定義 abstract repository，其他 repository 則繼承此 abstract repository。</p>
<blockquote>
<p>這裡的 model 指的是 .NET 的 entity，以 ORM 來描述 table 的一筆資料，而 CodeIgniter 的 model 則類似於 repository。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRepository</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> 注入的model */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$model</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根據 key 找單一筆資料 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(int <span class="variable">$id</span>, <span class="variable">$columns</span> = [<span class="string">'*'</span>])</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 回傳全部資料 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">all</span><span class="params">(<span class="variable">$columns</span> = [<span class="string">'*'</span>])</span>: <span class="title">array</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 新增資料 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(array <span class="variable">$data</span>)</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改資料 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">(array <span class="variable">$data</span>)</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 刪除資料 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span><span class="params">(int <span class="variable">$id</span>)</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">AbstractRepository</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> __construct(Order <span class="variable">$order</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct();</span><br><span class="line">        <span class="variable">$this</span>-&gt;order = <span class="variable">$order</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這種架構 <code>OrderRepository</code> 繼承了 <code>AbstractRepository</code>，因此 <code>OrderRepository</code> 就有了 <code>AbstractRepository</code> 的 <code>find()</code> 、<code>all()</code> 、<code>create()</code> 、<code>update()</code> 與 <code>delete()</code> 功能，這些都是每個 repository 都會有的 method。</p>
<p>這種架構看似很好，但仔細去看 <code>AbstractRepository</code>，仍有一些問題 :</p>
<p>第 3 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@var</span> 注入的model */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$model</span>;</span><br></pre></td></tr></table></figure>
<p><code>$model</code> 因為可能是各種型別，所以無法宣告型別，不過目前 PHP 還無法對 field 下 type hint。</p>
<p>第 6 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 根據 key 找單一筆資料 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(int <span class="variable">$id</span>, <span class="variable">$columns</span> = [<span class="string">'*'</span>])</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>find()</code> 理論上應該回傳 model 型別，但為了支援各種 model，只好選擇不用 return type，但也因此 <code>find()</code> 的接受物件喪失了 intellisense。</p>
<p>12 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 回傳全部資料 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">all</span><span class="params">(<span class="variable">$columns</span> = [<span class="string">'*'</span>])</span>: <span class="title">array</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>all()</code> 會傳回多筆資料，return type 使用了 <code>array</code> 這種概括型別，但 <code>all()</code>  的接受物件將喪失 array 內物件的 intellisense。</p>
<p>18 行</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 新增資料 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(array <span class="variable">$data</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改資料 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">(array <span class="variable">$data</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create()</code> 與 <code>update()</code> 為了讓各種 model 的 repository 都能套用，因而退守改用 <code>array</code> 這種概括型別，理論上應該將 model 型別的 <code>物件</code> 傳入較佳。</p>
<blockquote>
<p>Array 的缺點</p>
<ul>
<li>Array 是個概括型別，使用了之後，array 內部的物件都會喪失 intellisense</li>
<li>Array 與 null 很像，只要在底層用了 array 或 null，如 repository，就會逼得 service 與 controller 也繼續用 array 或 null</li>
</ul>
<p>若有了 generics，就可以完美解決這個問題</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractRepository&lt;T&gt; &#123;</span><br><span class="line">    /** 注入的model */</span><br><span class="line">    protected model: T;</span><br><span class="line"></span><br><span class="line">    /** 根據 key 找單一筆資料 */</span><br><span class="line">    find(id: number, columns = ['*']): T &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    /** 回傳全部資料 */</span><br><span class="line">    function all(columns = ['*']): T[] &#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 新增資料 */</span><br><span class="line">    create(data: T) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 修改資料 */</span><br><span class="line">    update(data: T) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 刪除資料 */</span><br><span class="line">    delete(id: number) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OrderRepository extends AbstractRepository&lt;Order&gt; &#123;</span><br><span class="line">    constructor(protected order: Order) &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 3 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 注入的model */</span></span><br><span class="line"><span class="keyword">protected</span> model: T;</span><br></pre></td></tr></table></figure>
<p>宣告 <code>model</code> 為泛型 <code>T</code>。</p>
<p>第 5 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 根據 key 找單一筆資料 */</span></span><br><span class="line">find(id: <span class="built_in">number</span>, columns = [<span class="string">'*'</span>]): T &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>find()</code> 的 return type 也有了 model 的明確型別，為泛型 <code>T</code>。</p>
<p>10 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 回傳全部資料 */</span></span><br><span class="line">all(columns = [<span class="string">'*'</span>]): T[] &#123;</span><br><span class="line">    ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>all()</code> 的 return type 由 <code>T[]</code> 取代 <code>array</code>，有了 model 的明確的型別。 </p>
<p>16 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 新增資料 */</span></span><br><span class="line">create(data: T) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改資料 */</span></span><br><span class="line">update(data: T) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create()</code> 與 <code>update()</code> 的 parameter 由 <code>array</code> 改成 <code>T</code>，有了 model 的明確型別。</p>
<p>31 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> OrderRepository extends AbstractRepository&lt;Order&gt; &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(protected order: Order) </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在繼承 <code>AbstractRepository</code> 時，把 <code>Order</code> 的 type parameter 明確帶入，因此 <code>AbstractRepository</code> 的 <code>T</code> 都是 <code>Order</code> model。</p>
<blockquote>
<p>改用泛型後，Repository 的型別可由 type parameter 指定，不再為了支援各種 model 而放棄 type hint 或改用 array。</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>C# 也有 generics，因此學習 TypeScript 的 generics 觀念，完全可用在 C#。</li>
<li>因為 interface 是在執行階段切換，所以又稱為 <code>動態多型</code>，而 generics 是在編譯階段切換，又稱為 <code>靜態多型</code>。</li>
<li>因為 generics 是在編譯階段處理，所以執行效率會比 interface 高。</li>
<li><code>&lt;T&gt;</code> 要放在 function 還是要放在 class 或 interface 都有它的優缺點，要看實際狀況決定。</li>
<li>泛型讓我們在寫程式時，能以支援各種型別來思考，但使用上又能享受強型別的 intellisense 與編譯時期檢查，非常好用。</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>, <a href="https://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">Handbook : Generics</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Generics 是 TypeScript 一大特色]]>
    
    </summary>
    
      <category term="TypeScript" scheme="http://oomusou.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探討 F# 之 Discriminated Union]]></title>
    <link href="http://oomusou.io/fsharp/union/"/>
    <id>http://oomusou.io/fsharp/union/</id>
    <published>2018-03-17T02:23:43.000Z</published>
    <updated>2018-03-17T13:56:20.372Z</updated>
    <content type="html"><![CDATA[<p>將實質上不同的型別，在邏輯上看成相同的型別。如 function 可能回傳 <code>int</code> 或 <code>bool</code> 兩種型別，可為此 function 特別建立 <code>IntOrBool</code> 型別，同時包含 <code>int</code> 與 <code>bool</code>，這就是 Discriminated Union，簡稱 <code>union</code>。</p>
<p>若說 <code>tuple</code> 是將不同型別加以 AND，則 <code>union</code> 是將不同型別加以 OR。</p>
<a id="more"></a>
<h2 id="Definition">Definition</h2><hr>
<p>將不同的型別，整合成單一型別。</p>
<blockquote>
<p>Q : 為什麼要稱為 <code>Discriminated</code> Union？</p>
</blockquote>
<p>因為不是簡單的將不同型別加以 union 而已，而可以將不同的型別取 <code>case-identifier</code> 加以區別 (discriminated)，所以稱為 <code>Discriminated</code> Union。</p>
<h2 id="Syntax">Syntax</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ attributes ]&#10;type type-name =&#10;    | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]&#10;    | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]&#10;...</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>type-name</strong> : 定義 <code>union</code> 的型別名稱</li>
<li><strong>I</strong> : 因為 <code>union</code> 包含多種型別，所以使用 <code>|</code>，第一個 <code>|</code> 可省略</li>
<li><strong>case-identifider</strong> : 為每個型別取一個別名，必須為 <code>大駝峰</code></li>
<li><strong>of</strong> : 每個別名的型別，可以是內建型別，也可以是自己定義的其他 type</li>
<li><strong>*</strong> : 若 <code>of</code> 之後為 <code>tuple</code>，不同 type 以 <code>*</code> 區別不同型別</li>
<li><strong>fieldname</strong> : 若 <code>of</code> 型別是 <code>tuple</code>，可為 <code>tuple</code> 內每個型別取別名</li>
</ul>
<p>以上只有 <code>type-name</code> 與 <code>case-identifier</code> 為必須，其他都可省略。</p>
<blockquote>
<p>簡單來說，<code>|</code> 之後稱為 case，<code>of</code> 之後稱為 field</p>
<p>Case 不可省略，但 field 可省略</p>
</blockquote>
<h2 id="Case">Case</h2><hr>
<p><strong>Case of Primitive Type</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">OrderId</span> </span>= </span><br><span class="line">  | Int <span class="keyword">of</span> int</span><br><span class="line">  | Bool <span class="keyword">of</span> bool</span><br></pre></td></tr></table></figure>
<p>如 function 找得到資料會傳回 <code>int</code> 型態的的 <code>orderId</code>，若找不到則傳回 <code>bool</code> 型態的 <code>false</code>，也就是回傳型態可能是 <code>int</code> 或  <code>bool</code>，可將此型態重新定義為 <code>OrderId</code> union，則無論傳回 <code>int</code> 或 <code>bool</code> 都是 <code>OrderId</code> union，且也只能傳回 <code>int</code> 或  <code>bool</code>。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">OrderId</span> </span>= Int <span class="keyword">of</span> int | Bool <span class="keyword">of</span> bool</span><br></pre></td></tr></table></figure>
<p>若 case 很少，也可以寫成一行，則第一個 <code>|</code> 可省略。</p>
<p><strong>Case of Unnamed Type</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Shape</span> </span>=</span><br><span class="line">    | Rectangle <span class="keyword">of</span> int * int</span><br><span class="line">    | Circle <span class="keyword">of</span> int</span><br><span class="line">    | Prism <span class="keyword">of</span> int * int * int</span><br></pre></td></tr></table></figure>
<p><code>of</code> 之後的型別，如是 unnamed type，可以直接 inline 表示，如直接指定為 <code>tuple</code> 。</p>
<p>如打算將 <code>Rectangle</code>、<code>Circle</code> 與 <code>Prism</code> 三個型別定義出一個新的 <code>Shape</code> union，只要是 <code>Rectangle</code> 或 <code>Circle</code> 或 <code>Prism</code> 之一，都算是 <code>Shape</code>。</p>
<ul>
<li><code>Rectangle</code> 為 <code>int</code> * <code>int</code> 組合的 <code>tuple</code></li>
<li><code>Circle</code> 為 <code>int</code></li>
<li><code>Prism</code> 為 <code>int</code> <em> <code>int</code> </em> <code>int</code> 組合的 <code>tuple</code></li>
</ul>
<blockquote>
<p>type * type 為 tuple 的型別定義方式</p>
</blockquote>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MixedType</span> </span>= </span><br><span class="line">    Tuple <span class="keyword">of</span> int * int</span><br><span class="line">    List <span class="keyword">of</span> int list</span><br></pre></td></tr></table></figure>
<p><code>Collection</code> 也屬於 unnamed type，亦可直接 inline 表示。</p>
<blockquote>
<p><code>int list</code> 表示為 <code>list</code> 型別，其 element 型別為 <code>int</code>。</p>
</blockquote>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rectangle = Rectangle (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> circle = Circle <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> prism = Prism (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>當建立 <code>union</code> 時，以類似 constructor 的方式建立，稱為 case constructor，唯沒有 <code>new</code>， <code>class</code> 換成 <code>case</code>，且必須要照 <code>定義順序</code> 傳入。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">C</span> </span>= </span><br><span class="line">    | Circle <span class="keyword">of</span> int </span><br><span class="line">    | Rectangle <span class="keyword">of</span> int * int</span><br><span class="line"></span><br><span class="line">[<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">|&gt; List.map Circle</span><br><span class="line"></span><br><span class="line">[<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">|&gt; List.zip [<span class="number">21.</span><span class="number">.30</span>]</span><br><span class="line">|&gt; List.map Rectangle</span><br></pre></td></tr></table></figure>
<p>Case contructor 本質就是 function，因此任何可傳入 function 之處，就可傳入 case constructor。</p>
<p><strong>Case of Named Type</strong></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Person</span> </span>= &#123; first: string; last: string &#125;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">IntOrBool</span> </span>= Int <span class="keyword">of</span> int | Bool <span class="keyword">of</span> bool</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MixedType</span> </span>= </span><br><span class="line">    | Person <span class="keyword">of</span> Person       </span><br><span class="line">    | IntOrBool <span class="keyword">of</span> IntOrBool</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MixedType</span> </span>= </span><br><span class="line">    | Person <span class="keyword">of</span>  &#123; first: string; last: string &#125;  <span class="comment">// error</span></span><br><span class="line">    | IntOrBool <span class="keyword">of</span> (Int <span class="keyword">of</span> int | Bool <span class="keyword">of</span> bool)    <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p><code>of</code> 之後的型別若是 named type，則必須先用 <code>type</code> 定義好型別，如 <code>record</code> 或 <code>union</code>，不能以 inline 的方式表示。</p>
<h2 id="Field">Field</h2><hr>
<p>若 case 的型別為 <code>tuple</code>，雖能在 <code>of</code> 之後簡單的宣告 <code>int * int</code>，有幾個缺點 :</p>
<ol>
<li>要建立 <code>union</code> 時，只能依照 <code>定義順序</code> 傳入，可讀性較差</li>
<li>無法由 <code>tuple</code> 看出其 domain 上的意義</li>
</ol>
<p>若我們加上 field，則清楚許多。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Shape</span> </span>=</span><br><span class="line">    | Rectangle <span class="keyword">of</span> width : int * length : int</span><br><span class="line">    | Circle <span class="keyword">of</span> radius: int</span><br><span class="line">    | Prism <span class="keyword">of</span> width: int * length : int * height: int</span><br></pre></td></tr></table></figure>
<p>在 <code>of</code> 之後加上 field，可明確表達出 <code>tuple</code> 的每個 element 的 domain 意義。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rectangle = Rectangle (length = <span class="number">1</span>, width = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> circle = Circle (radius = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> prism = Prism (width = <span class="number">1</span>, length = <span class="number">2</span>, height = <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>建立 <code>union</code> 時，可在 case constructor 明確指定其 field，如此可讀性更高，且不用依照 <code>定義順序</code> 傳入。</p>
<h2 id="Empty_Case">Empty Case</h2><hr>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Directory</span> </span>= </span><br><span class="line">    | Root                   </span><br><span class="line">    | Subdirectory <span class="keyword">of</span> string</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span> </span>= </span><br><span class="line">    | Success                </span><br><span class="line">    | ErrorMessage <span class="keyword">of</span> string</span><br></pre></td></tr></table></figure>
<p>Case 並不一定要搭配 type，若該 case 並不需要任何型態的值傳入，可以不指定 type。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDir1 = Root</span><br><span class="line"><span class="keyword">let</span> myDir2 = Subdirectory <span class="string">"bin"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myResult1 = Success</span><br><span class="line"><span class="keyword">let</span> myResult2 = ErrorMessage <span class="string">"not found"</span></span><br></pre></td></tr></table></figure>
<p>沒有 type 的 case，其 case constructor 就不用傳入任何值。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Size</span> </span>= Small | Medium | Large</span><br><span class="line"><span class="keyword">let</span> mySize = Small</span><br></pre></td></tr></table></figure>
<p>當全部 case 都沒有 type 時，其功能等效於 <code>enum</code>。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Size</span> </span>= Small     | Medium     | Large     <span class="comment">// DU</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Size</span> </span>= Small = <span class="number">0</span> | Medium = <span class="number">1</span> | Large = <span class="number">2</span> <span class="comment">// enum</span></span><br></pre></td></tr></table></figure>
<p><code>union</code> 與 <code>enum</code> 都使用 type 定義，沒有指定 <code>int</code> 值為 <code>union</code>，有則為 <code>enum</code>。</p>
<blockquote>
<p>Q : F# 也有 <code>enum</code>，我該用 <code>union</code> 還是 <code>enum</code> 呢 ?</p>
</blockquote>
<p>F# 的 <code>union</code> 功能較強，<code>enum</code> 只是 <code>union</code> 的特例，實務上應優先使用 <code>union</code>，除非有以下需求：</p>
<ol>
<li>Case 必須搭配 <code>int</code></li>
<li><code>union</code> 必須與其他 .NET 語言搭配時</li>
</ol>
<p>才必須使用 <code>enum</code>。</p>
<blockquote>
<p>F# 的 <code>enum</code> 與 .NET 的 <code>enum</code> 是相同的</p>
</blockquote>
<h2 id="Single_Case">Single Case</h2><hr>
<p>雖然 <code>union</code> 原本的用途是用在將不同的型別整合成單一型別，也就是將不同的 case 整合成一個 <code>union</code>，但實務上有一種應用是一個 <code>union</code> 只有一個 case，所謂的 single case。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CustomerId</span> </span>= int</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">OrderId</span> </span>= int</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printOrderId (orderId: OrderId) = </span><br><span class="line">   printfn <span class="string">"The orderId is %i"</span> orderId</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> custId = <span class="number">1</span></span><br><span class="line">printOrderId custId</span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomerId = int</span><br><span class="line"><span class="keyword">type</span> OrderId = int</span><br></pre></td></tr></table></figure>
<p><code>type</code> 能對 primitive type 取 alias，所以我們分別對  <code>int</code> 定義成 <code>CustomerId</code> type 與 <code>OrderId</code> type。</p>
<p>第 4 行</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printOrderId (orderId: OrderId) = </span><br><span class="line">   printfn <span class="string">"The orderId is %i"</span> orderId</span><br></pre></td></tr></table></figure>
<p>建立 <code>printOrderId</code> function，傳入參數的型別為 <code>OrderId</code>。</p>
<p>第 7 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> custId = <span class="number">1</span></span><br><span class="line">printOrderId custId</span><br></pre></td></tr></table></figure>
<p><code>custId</code> 的型別為 <code>int</code>，傳入 <code>printOrderId</code> compiler 也沒報錯，明明要的是 <code>OrderId</code> 型別。</p>
<p>因為 <code>OrderId</code> 與 <code>CustomerId</code> 都只能算是 <code>int</code> 的 alias，還不算是個型別。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CustomerId</span> </span>= CustomerId <span class="keyword">of</span> int</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">OrderId</span> </span>= OrderId <span class="keyword">of</span> int</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printOrderId (OrderId orderId) =</span><br><span class="line">   printfn <span class="string">"The orderId is %i"</span> orderId</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> custId = CustomerId <span class="number">1</span></span><br><span class="line">printOrderId custId                   <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">CustomerId</span> </span>= CustomerId <span class="keyword">of</span> int</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">OrderId</span> </span>= OrderId <span class="keyword">of</span> int</span><br></pre></td></tr></table></figure>
<ul>
<li>定義 <code>CustomerId</code> union，其 case 為 <code>CustomerId</code>，型別為 <code>int</code></li>
<li>定義 <code>OrderId</code> union，其 case 為 <code>OrderId</code>，型別為 <code>int</code></li>
</ul>
<blockquote>
<p>當使用 single case 的 <code>union</code> 時，type 會與 case 相同</p>
</blockquote>
<p>第 4 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printOrderId (OrderId orderId) =</span><br><span class="line">   printfn <span class="string">"The orderId is %i"</span> orderId</span><br></pre></td></tr></table></figure>
<p>建立 <code>printOrderId</code> function，傳入參數的型別為 <code>OrderId</code>。</p>
<p>與之前的 <code>printOrderId</code> function 一樣。</p>
<p>第 7 行</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> custId = CustomerId <span class="number">1</span></span><br><span class="line">printOrderId custId                   <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p><code>custId</code> 型別不再是 <code>int</code>，而是 <code>CustomerId</code>，因為使用了 <code>CustomerId</code>  的 case constructor 建立。</p>
<p><code>custId</code> 傳入  <code>printOrderId</code> 後，如願出現 compiler error，因為 <code>OrderId</code> 與 <code>CustomerId</code> 都是具體的 type，而不只是 alias。</p>
<h2 id="Destructor">Destructor</h2><hr>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getShapeHeight shape =</span><br><span class="line">    <span class="keyword">match</span> shape <span class="keyword">with</span></span><br><span class="line">    | Rectangle(height = h) -&gt; h</span><br><span class="line">    | Circle(radius = r) -&gt; <span class="number">2.</span> * r</span><br><span class="line">    | Prism(height = h) -&gt; h</span><br></pre></td></tr></table></figure>
<p>當 <code>union</code> 傳入 function 後，可使用 Pattern Matching 與 field 將 <code>tuple</code> 的值取出。</p>
<p><code>with</code> 之後配合的 <code>union</code> 的 case，<code>()</code> 內配合 field，可以直接取出該 field 的值。</p>
<blockquote>
<p>使用 field 之後，可輕易的配合 Pattern Matching 取出 <code>tuple</code> 內的值</p>
</blockquote>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getCustomerId (CustomerId customerId) = </span><br><span class="line">    printfn <span class="string">"The CustomerId is %i"</span> customerId</span><br></pre></td></tr></table></figure>
<p>在 function 的 paramter 使用 <code>()</code>，將 case 寫在 parameter 之前，則自動會將傳入的 <code>union</code> destruct 成 value。</p>
<blockquote>
<p>語法雖然很類似 C#，但別忘了 F# 的 type 是在 <code>:</code> 之後，所以 <code>CustomerId</code> 寫在前面並不是型別，而是 <code>union</code> 的 case</p>
</blockquote>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (CustomerId customerId) = custId </span><br><span class="line"><span class="keyword">let</span> CustomerId customerIdInt = custId <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p><code>custId</code> 為 <code>CustomerId</code> union，會直接 destruct 成 <code>customerId</code>。</p>
<blockquote>
<p>使用 destructor 時，一定要加上 <code>()</code>，否則會誤以為是新的 function</p>
</blockquote>
<h2 id="Equality">Equality</h2><hr>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Contact</span> </span>= </span><br><span class="line">    | Email <span class="keyword">of</span> string </span><br><span class="line">    | Phone <span class="keyword">of</span> int</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> email1 = Email <span class="string">"bob@example.com"</span></span><br><span class="line"><span class="keyword">let</span> email2 = Email <span class="string">"bob@example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> areEqual = (email1=email2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>雖然 <code>union</code> 為 reference type，但 <code>union</code> 的比較卻像 value type，只要 type 一樣，value 一樣，<code>union</code> 就算一樣。</p>
<h2 id="Representation">Representation</h2><hr>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Contact</span> </span>= Email <span class="keyword">of</span> string | Phone <span class="keyword">of</span> int</span><br><span class="line"><span class="keyword">let</span> email = Email <span class="string">"bob@example.com"</span></span><br><span class="line"></span><br><span class="line">printfn <span class="string">"%A"</span> email    <span class="comment">// nice</span></span><br></pre></td></tr></table></figure>
<p><code>printfn</code> 使用 <code>%A</code> 支援 <code>union</code>。</p>
<h2 id="Object_Hierarchy">Object Hierarchy</h2><hr>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Shape</span> </span>=</span><br><span class="line">    | Circle <span class="keyword">of</span> float</span><br><span class="line">    | EquilateralTriangle <span class="keyword">of</span> double</span><br><span class="line">    | Square <span class="keyword">of</span> double</span><br><span class="line">    | Rectangle <span class="keyword">of</span> double * double</span><br></pre></td></tr></table></figure>
<p>若使用 OOP，會設計 <code>Shape</code> interface，再由 <code>Circle</code>、<code>EquilateralTriangle</code>、<code>Square</code> 與 <code>Rectangle</code> 實踐 <code>Shape</code>，如此需要開 5 個檔案。</p>
<p>若使用 <code>union</code>，只要 5 行就可解決。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pi = <span class="number">3.141592654</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> area myShape =</span><br><span class="line">    <span class="keyword">match</span> myShape <span class="keyword">with</span></span><br><span class="line">    | Circle radius -&gt; pi * radius * radius</span><br><span class="line">    | EquilateralTriangle s -&gt; (sqrt <span class="number">3.0</span>) / <span class="number">4.0</span> * s * s</span><br><span class="line">    | Square s -&gt; s * s</span><br><span class="line">    | Rectangle (h, w) -&gt; h * w</span><br></pre></td></tr></table></figure>
<p>若使用 OOP，由於各種形狀計算面積的公式不同，勢必在 <code>Shape</code> interface 開 <code>area()</code>，再由  <code>Circle</code>、<code>EquilateralTriangle</code>、<code>Square</code> 與 <code>Rectangle</code> 各自實作 <code>area()</code>。</p>
<p>但在 FP 的 F#，只需使用 pattern matching 根據 <code>union</code> 的不同 case 實作即可，6 行即可解決。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>F# 的 <code>union</code> 非常強大，可以算是 <code>enum</code> 的威力加強版，搭配 Pattern Matching 更是如虎添翼</li>
<li><code>union</code> 配合 <code>tuple</code> 可以定義出複雜的 domain model</li>
<li>Single case 的 <code>union</code> 可以替 domain 定義一個更有意義的型別名稱，且兼具 type safety 與 compiler 保護</li>
</ul>
<h2 id="Reference">Reference</h2><p><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/" target="_blank" rel="external">F#</a>, <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions" target="_blank" rel="external">Discriminated Unions</a><br><a href="https://fsharpforfunandprofit.com" target="_blank" rel="external">F# for fum and profit</a>, <a href="https://fsharpforfunandprofit.com/posts/discriminated-unions/" target="_blank" rel="external">Discriminated Unions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[將不同型別 OR 起來]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
      <category term="F#" scheme="http://oomusou.io/tags/F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何管理 Package Reference ?]]></title>
    <link href="http://oomusou.io/netcore/package-reference/"/>
    <id>http://oomusou.io/netcore/package-reference/</id>
    <published>2018-03-17T01:23:43.000Z</published>
    <updated>2018-03-19T02:12:29.063Z</updated>
    <content type="html"><![CDATA[<p>實務上我們一定會用到別人寫的 NuGet package，我們該如何使用 .NET Core SDK 加入 package reference 呢 ?</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="建立_Console_App_專案">建立 Console App 專案</h2><hr>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> <span class="built_in">console</span> -o MyConsole</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new</code> 建立 project。</p>
<ul>
<li><strong>console</strong> : 建立 console 類型專案</li>
<li><strong>-o</strong> : <code>o</code> output，建立在 <code>MyConsole</code> 目錄下</li>
</ul>
<p><img src="/images/netcore/package-reference/pkg000.png" alt="kg00"></p>
<ol>
<li>輸入 <code>dotnet new console -o MyConsole</code> 將 console 類型專案建立在 <code>MyConsole</code> 目錄下</li>
<li>.NET Core SDK 開始建立專案所需的檔案</li>
<li>自動 restore dependency</li>
</ol>
<h2 id="使用_VS_Code_開啟專案">使用 VS Code 開啟專案</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">code</span> MyConsole</span><br></pre></td></tr></table></figure>
<p>使用 <code>code</code> 執行 VS Code，後面接開啟目錄名稱。</p>
<p><img src="/images/netcore/package-reference/pkg001.png" alt="onsole00"></p>
<ol>
<li>第一次使用 VS Code 開啟 .NET Core 專案，會要求建立 <code>.vscode</code> 設定檔目錄，按 <code>Yes</code> 繼續</li>
</ol>
<p><img src="/images/netcore/package-reference/pkg002.png" alt="onsole01"></p>
<ol>
<li><code>.vscode</code> 被 VS Code 自動建立</li>
</ol>
<h2 id="新增_Package_Reference">新增 Package Reference</h2><hr>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyProject $ dotnet <span class="built_in">add</span> <span class="keyword">package</span> Newtonsoft.Json</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet add package</code> 加入 NuGet package。</p>
<p><img src="/images/netcore/package-reference/pkg003.png" alt="kg00"></p>
<ol>
<li>輸入 <code>dotnet add package Newtonsoft.Json</code> 新增 <code>Newtonsoft.Json</code> package</li>
</ol>
<h2 id="編輯_Program-cs">編輯 Program.cs</h2><hr>
<p><strong>program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyConsole</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> students = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Sam"</span>,</span><br><span class="line">                <span class="string">"Kevin"</span>,</span><br><span class="line">                <span class="string">"Jessie"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = JsonConvert.SerializeObject(students);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>JsonConvert.SerializeObject()</code> 將 <code>List</code> 轉成 JSON string。</p>
<h2 id="執行_Console_App">執行 Console App</h2><hr>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyProject $ dotnet <span class="command">run</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet run</code> 執行專案。</p>
<p><img src="/images/netcore/package-reference/pkg004.png" alt="kg00"></p>
<ol>
<li>輸入 <code>dotnet run</code> 顯示執行結果</li>
</ol>
<h2 id="其他相關指令">其他相關指令</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet remove <span class="package"><span class="keyword">package</span> <span class="title">Newtonsoft</span>.<span class="title">Json</span></span></span><br></pre></td></tr></table></figure>
<p>移除 package reference。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>使用 <code>dotnet add package</code> 與 <code>dotnet remove package</code>，我們就可在 project 中新增與移除 NuGet package</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[使用 .NET Core SDK 管理 Package Reference]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何建立 Solution ?]]></title>
    <link href="http://oomusou.io/netcore/solution/"/>
    <id>http://oomusou.io/netcore/solution/</id>
    <published>2018-03-17T00:23:43.000Z</published>
    <updated>2018-03-19T02:12:57.838Z</updated>
    <content type="html"><![CDATA[<p>對於大型專案，我們可以建立 solution 管理眾多 project，只要對 solution 下 <code>dotnet build</code> ，就可以全部 project 都一起 build。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="建立_Solution">建立 Solution</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> sln -n MySolution</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new sln</code> 建立 solution。</p>
<ul>
<li><strong>-n</strong> : 建立 <code>.sln</code> 檔案即可，不用建立目錄</li>
</ul>
<blockquote>
<p>Solution 是 Microsoft 技術特別的觀念，算 project 的集合，一個 solution 可以有多個 project</p>
</blockquote>
<p><img src="/images/netcore/solution/sln000.png" alt="sln00"></p>
<ol>
<li>輸入 <code>dotnet new sln -n MySolution</code> 在目前目錄建立 <code>MySolution.sln</code></li>
<li>已建立 <code>MySolution.sln</code> 在目前目錄下</li>
</ol>
<h2 id="將_Project_加入_Solution">將 Project 加入 Solution</h2><hr>
<p><strong>macOS/Linux</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet sln MySolution.sln add <span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>.csproj</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet sln … add</code> 將 project 加入 solution</p>
<blockquote>
<p><code>**/*.csproj</code> 表示目前目錄下 <code>所有子目錄</code> 的 <code>cspoj</code></p>
</blockquote>
<p><img src="/images/netcore/solution/sln001.png" alt="ln00"></p>
<ol>
<li>輸入 <code>dotnet sln MySolution.sln add **/*.csproj</code> 將目前目錄下的所有 project 都加入 <code>MySolution.sln</code></li>
</ol>
<p><strong>Windows</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet sln MySolution<span class="class">.sln</span> add MyConsole/MyConsole<span class="class">.csproj</span></span><br><span class="line">$ dotnet sln MySolution<span class="class">.sln</span> add MyClassLib/MyClassLib<span class="class">.csproj</span></span><br><span class="line">$ dotnet sln MySolution<span class="class">.sln</span> add MyClassLib.Tests/MyClassLib<span class="class">.Tests</span><span class="class">.csproj</span></span><br></pre></td></tr></table></figure>
<p>Windows 只能乖乖地用 <code>3</code> 次 <code>dotnet sln … add</code> 。</p>
<p><img src="/images/netcore/solution/sln002.png" alt="ln00"></p>
<ol>
<li>一個一個 project 加入 <code>MySolution.sln</code></li>
</ol>
<h2 id="編譯整個_Solution">編譯整個 Solution</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">build </span>MySolution.sln</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 將 solution 下所有 project 一起編譯。</p>
<p><img src="/images/netcore/solution/sln003.png" alt="ln00"></p>
<ol>
<li>輸入 <code>dotnet build MySolution.sln</code> 編譯整個 <code>MySolution</code></li>
<li><code>MySolution</code> 下所有 project 都執行 <code>dotnet restore</code></li>
<li><code>MySoluton</code> 下所有 project 都執行 <code>dotnet build</code> 編譯新的 dll</li>
</ol>
<h2 id="將整個_Solution_建立_Package">將整個 Solution 建立 Package</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>dotnet pack <span class="constant">MySolution.</span>sln</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet pack</code> 將 solution 下所有 project 建立 NuGet package。</p>
<p><img src="/images/netcore/solution/sln004.png" alt="ln00"></p>
<ol>
<li>輸入 <code>dotnet pack MySolution.sln</code> 將整個 <code>MySolution</code> 建立 package</li>
<li><code>MySolution</code> 下所有 project 都執行 <code>dotnet restore</code></li>
<li><code>MySoluton</code> 下所有 project 都執行 <code>dotnet pack</code> </li>
</ol>
<blockquote>
<p>只有 <code>MyConsole</code> 與 <code>MyClassLib</code> 會建立 package，<code>MyClassLib.Tests</code> 因為是 Unit Test，所以不會建立 package</p>
</blockquote>
<h2 id="發佈整個_Solution">發佈整個 Solution</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>dotnet publish <span class="constant">MySolution.</span>sln</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet publish</code> 將 solution 下所有 project 都加以 publish。</p>
<p><img src="/images/netcore/solution/sln005.png" alt="ln00"></p>
<ol>
<li>輸入 <code>dotnet publish MySolution.sln</code> 將整個 <code>MySolution</code> 下的所有 project 都加以 publish</li>
<li><code>MySolution</code> 下所有 project 都執行 <code>dotnet restore</code></li>
<li><code>MySoluton</code> 下所有 project 都執行 <code>dotnet publish</code> </li>
</ol>
<h2 id="其他相關指令">其他相關指令</h2><hr>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet sln <span class="keyword">*</span>.sln remove <span class="keyword">*</span>.csproj</span><br></pre></td></tr></table></figure>
<p>將 project 從 solution 移除。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet sln *<span class="class">.sln</span> list</span><br></pre></td></tr></table></figure>
<p>列出 solution 共有哪些 project。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Solution 在 .NET Core SDK 中，重要性已經不如 Visual Studio，但對於大型專案，卻可透過 solution 對所有 project 下指令，還是非常好用</li>
<li>VS Code 不一定要使用 solution，但若專案也需要被 Visual Studio 或 Rider 開啟，則建議建立 solution</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[使用 .NET Core SDK 建立 Solution]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何建立 Unit Test ?]]></title>
    <link href="http://oomusou.io/netcore/unit-test/"/>
    <id>http://oomusou.io/netcore/unit-test/</id>
    <published>2018-03-16T23:23:43.000Z</published>
    <updated>2018-03-19T02:13:03.167Z</updated>
    <content type="html"><![CDATA[<p>雖然我們可以使用 console app 來測試 class library，但比較好的方式是建立 unit test，搭配各種測試案例測試 class library 的結果。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="建立_Unit_Test_專案">建立 Unit Test 專案</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> mstest -o MyClassLib.Tests</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new</code> 建立 project。</p>
<ul>
<li><strong>mstest</strong> : 建立  MSTest 類型專案</li>
<li><strong>-o</strong> : <code>o</code> output，建立在 <code>MyClassLib.Tests</code> 目錄下</li>
</ul>
<p><img src="/images/netcore/unit-test/ut000.png" alt="t00"></p>
<ol>
<li>輸入 <code>dotnet new mstest -o MyClasLib.Tests</code> 將 MSTest 類型專案建立在 <code>MyClassLib.Tests</code> 目錄下</li>
<li>.NET Core SDK 開始建立專案所需的檔案</li>
<li>自動 restore dependency</li>
</ol>
<blockquote>
<p>除了 MSTest，.NET Core SDK 預設還支援 xUnit，若想使用 NUnit，可到 <a href="https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new" target="_blank" rel="external">Available templates for dotnet new</a> 下載 NUnit project template</p>
</blockquote>
<h2 id="使用_VS_Code_開啟專案">使用 VS Code 開啟專案</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">code</span> MyClassLib.Tests</span><br></pre></td></tr></table></figure>
<p>使用 <code>code</code> 執行 VS Code，後面接開啟目錄名稱。 </p>
<p><img src="/images/netcore/unit-test/ut001.png" alt="t00"></p>
<ul>
<li>使用 VS Code 開啟 <code>MyClassLib.Tests</code></li>
</ul>
<h2 id="新增_Project_Reference">新增 Project Reference</h2><hr>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyProject $ dotnet <span class="keyword">add</span> <span class="keyword">reference</span> ../MyClassLib/MyClassLib.csproj</span><br></pre></td></tr></table></figure>
<p>因為 <code>MyClassLib.Tests</code> 需要使用 <code>MyClassLib</code>，所以使用 <code>dotnet add reference</code> 新增 project reference。</p>
<p><img src="/images/netcore/unit-test/ut002.png" alt="t00"></p>
<ol>
<li>輸入 <code>dotnet add reference ../MyClassLib/MyClassLib.csproj</code> 將 <code>MyClassLib</code> project 加入 reference</li>
<li>觀察 <code>MyConsole.csproj</code></li>
<li><code>MyClassLib.csproj</code>  被加入在  <code>&lt;ItemGroup&gt;</code> 下的 <code>&lt;ProjectReference&gt;</code> </li>
<li>其他 package 被加入在 <code>&lt;ItemGroup&gt;</code> 下的 <code>&lt;PackageReference&gt;</code></li>
</ol>
<blockquote>
<p>Project reference 與 package reference 都被記錄在 <code>csproj</code> 中，其中 <code>&lt;ProjectReference&gt;</code> 紀錄 project reference，而 <code>&lt;PackageReference&gt;</code> 記錄 package reference</p>
</blockquote>
<h2 id="編輯_UnitTest1-cs">編輯 UnitTest1.cs</h2><hr>
<p><strong>UnitTest1.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyClassLib.Tests</span></span><br><span class="line">&#123;</span><br><span class="line">    [TestClass]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitTest1</span></span><br><span class="line">    &#123;</span><br><span class="line">        [TestMethod]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// Arrange</span></span><br><span class="line">            <span class="keyword">var</span> target = <span class="keyword">new</span> CalculatorService();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Act</span></span><br><span class="line">            <span class="keyword">var</span> actual = target.Sum(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assert</span></span><br><span class="line">            <span class="keyword">var</span> expected = <span class="number">2</span>;</span><br><span class="line">            Assert.AreEqual(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據 <code>3A原則</code> 建立 <code>CalculatorService</code> 的 Unit Test。</p>
<p><img src="/images/netcore/unit-test/ut003.png" alt="t00"></p>
<ol>
<li>開啟 <code>UnitTest1.cs</code></li>
<li>建立 <code>CalculatorService</code> 的 Unit Test</li>
</ol>
<h2 id="執行_Unit_Test">執行 Unit Test</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyProjet $ dotnet <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet test</code> 執行單元測試。</p>
<p><img src="/images/netcore/unit-test/ut004.png" alt="t00"></p>
<ol>
<li>輸入 <code>dotnet test</code> 執行單元測試</li>
<li>測試通過，得到 <code>綠燈</code></li>
</ol>
<h2 id="其他相關指令">其他相關指令</h2><hr>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">remove</span> <span class="keyword">reference</span> *.csproj</span><br></pre></td></tr></table></figure>
<p>移除 project reference。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="type">list</span> <span class="keyword">reference</span></span><br></pre></td></tr></table></figure>
<p>列出所有 project reference。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>.NET Core SDK 支援各種 Unit Test，包括 MSTest、xUnit 與 NUnit</li>
<li>使用 <code>dotnet add reference</code> 新增 project reference</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[使用 .NET Core SDK 建立 Unit Test]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何驗證 Class Library ?]]></title>
    <link href="http://oomusou.io/netcore/console/"/>
    <id>http://oomusou.io/netcore/console/</id>
    <published>2018-03-16T22:23:43.000Z</published>
    <updated>2018-03-19T02:08:07.099Z</updated>
    <content type="html"><![CDATA[<p>雖然我們可以使用 <code>ng new classlib</code> 建立 class library 型態專案，但畢竟是 class library，無法看到結果，此時我們會建立另外一個 console app 專案當成 client，用來測試 class library 的結果。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="建立_Console_App_專案">建立 Console App 專案</h2><hr>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> <span class="built_in">console</span> -o MyConsole</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new</code> 建立 project。</p>
<ul>
<li><strong>console</strong> : 建立 console 類型專案</li>
<li><strong>-o</strong> : <code>o</code> output，建立在 <code>MyConsole</code> 目錄下</li>
</ul>
<p><img src="/images/netcore/console/console000.png" alt="onsole00"></p>
<ol>
<li>輸入 <code>dotnet new console -o MyConsole</code> 將 console 類型專案建立在 <code>MyConsole</code> 目錄下</li>
<li>.NET Core SDK 開始建立專案所需的檔案</li>
<li>自動 restore dependency</li>
</ol>
<h2 id="使用_VS_Code_開啟專案">使用 VS Code 開啟專案</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">code</span> MyConsole</span><br></pre></td></tr></table></figure>
<p>使用 <code>code</code> 執行 VS Code，後面接開啟目錄名稱。</p>
<p><img src="/images/netcore/console/console001.png" alt="onsole00"></p>
<ol>
<li>第一次使用 VS Code 開啟 .NET Core 專案，會要求建立 <code>.vscode</code> 設定檔目錄，按 <code>Yes</code> 繼續</li>
</ol>
<p><img src="/images/netcore/console/console002.png" alt="onsole01"></p>
<ol>
<li><code>.vscode</code> 被 VS Code 自動建立</li>
</ol>
<h2 id="新增_Project_Reference">新增 Project Reference</h2><hr>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyProject $ dotnet <span class="keyword">add</span> <span class="keyword">reference</span> ../MyClassLib/MyClassLib.csproj</span><br></pre></td></tr></table></figure>
<p>因為 <code>MyConsole</code> 需要使用 <code>MyClassLib</code>，所以使用 <code>dotnet add reference</code> 新增 project reference。</p>
<p><img src="/images/netcore/console/console003.png" alt="onsole00"></p>
<ol>
<li>輸入 <code>dotnet add reference ../MyClassLib/MyClassLib.csproj</code> 將 <code>MyClassLib</code> project 加入 reference</li>
<li>觀察 <code>MyConsole.csproj</code></li>
<li><code>MyClassLib.csproj</code>  被加入在  <code>&lt;ItemGroup&gt;</code> 下的 <code>&lt;ProjectReference&gt;</code> </li>
</ol>
<blockquote>
<p>若你不想下 <code>dotnet add reference</code> 指令，也可以直接修改 <code>MyConsole.csproj</code> 檔案</p>
</blockquote>
<h2 id="編輯_Program-cs">編輯 Program.cs</h2><hr>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> MyClassLib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyConsole</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> calculatorService = <span class="keyword">new</span> CalculatorService();</span><br><span class="line">            <span class="keyword">var</span> result = calculatorService.Sum(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125; + &#123;1&#125; = &#123;2&#125;"</span>, <span class="number">1</span>, <span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立 <code>CalculatorService</code> 物件，並執行 <code>Sum()</code>。</p>
<p><img src="/images/netcore/console/console004.png" alt="onsole00"></p>
<ol>
<li>開啟 <code>Program.cs</code></li>
<li>建立 <code>CalculatorService</code> 物件並執行</li>
</ol>
<h2 id="編譯_Console_App">編譯 Console App</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyConsole $ dotnet <span class="keyword">build </span>-c Release</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet build</code> 是以 <code>Debug</code> 模式編譯，若要以 <code>Release</code> 編譯，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/console/console005.png" alt="onsole00"></p>
<ol>
<li>輸入 <code>dotnet build -c Release</code> 以 <code>Release</code> 模式編譯</li>
<li>自動執行 <code>dotnet restore</code></li>
<li>最後 build 出 <code>MyConsole.dll</code></li>
</ol>
<blockquote>
<p>注意 <code>dotnet restore</code> 與 <code>dotnet build</code> 時，<code>MyClassLib</code> 與 <code>MyConsole</code> 兩個專案都會重新 build 與 restore</p>
</blockquote>
<h2 id="執行_Console_App">執行 Console App</h2><hr>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyConsole $ dotnet <span class="command">run</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet run</code> 執行專案。</p>
<p><img src="/images/netcore/console/console006.png" alt="onsole00"></p>
<ol>
<li>輸入 <code>dotnet run</code> 顯示執行結果</li>
</ol>
<h2 id="發佈_Console_App">發佈 Console App</h2><hr>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">MyConsole</span> $ <span class="keyword">dotnet</span> publish -c <span class="type">Release</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet publish</code> 將編譯後的 dll 與其 dependency 整理到 <code>publish</code> 目錄，將來只要將此目錄 deploy 到 server 即可。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet publish</code> 是將 <code>Debug</code> 模式的 dll 整理至 <code>publish</code> 目錄，若要整理 <code>Release</code> 模式的的 dll，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/console/console007.png" alt="onsole00"></p>
<ol>
<li>輸入 <code>dotnet publish -c Release</code> 將欲 deploy 的檔案整理到 <code>bin/Release/netcoreapp2.0/publish</code> 目錄</li>
<li>在 <code>publish</code> 目錄下，我們發現除了有 <code>MyConsole.dll</code> 外，還有 reference 的 <code>MyClassLib.dll</code>，<code>dotnet publish</code> 也一並幫我們整理到 <code>publish</code> 目錄了</li>
</ol>
<h2 id="執行_Console_App-1">執行 Console App</h2><hr>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/MyProject $ dotnet run bin/</span>Release<span class="regexp">/netcoreapp2.0/</span>publish<span class="regexp">/MyConsole.dll</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet</code> 執行 publish 後的 dll。</p>
<p><img src="/images/netcore/console/console008.png" alt="onsole00"></p>
<ol>
<li>輸入 <code>dotnet</code> 直接執行  publish 過的 <code>MyConsole.dll</code></li>
<li>馬上出現 <code>1 + 1 = 2</code> ，不用等待</li>
</ol>
<h2 id="其他相關指令">其他相關指令</h2><hr>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">remove</span> <span class="keyword">reference</span> *.csproj</span><br></pre></td></tr></table></figure>
<p>移除 project reference。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="type">list</span> <span class="keyword">reference</span></span><br></pre></td></tr></table></figure>
<p>列出所有 project reference。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Console app 適合用來測試 class library</li>
<li>使用 <code>dotnet add reference</code> 新增 project reference</li>
<li><code>dotnet publish</code> 時，會一併將 class library 的 dll 也整理到 <code>publish</code> 目錄</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[使用 .NET Core SDK 建立 Class Library]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何建立 Class Library ?]]></title>
    <link href="http://oomusou.io/netcore/classlib/"/>
    <id>http://oomusou.io/netcore/classlib/</id>
    <published>2018-03-16T15:23:43.000Z</published>
    <updated>2018-03-19T02:07:58.045Z</updated>
    <content type="html"><![CDATA[<p>除了 Console app 扮演 client 的角色，另外一個常見需求就是建立自己的 class library，我們可以使用 <code>ng new classlib</code> 建立 class library 型態專案。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="建立_Class_Library_專案">建立 Class Library 專案</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> classlib -o MyClassLib</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new</code> 建立 project。</p>
<ul>
<li><strong>classlib</strong> : 建立 class library 類型專案</li>
<li><strong>-o</strong> : <code>o</code> output，建立在 <code>MyClassLib</code> 目錄下</li>
</ul>
<p><img src="/images/netcore/classlib/lib000.png" alt="ib00"></p>
<ol>
<li>輸入 <code>dotnet new classlib -o MyClasLib</code> 將 class library 類型專案建立在 <code>MyClassLib</code> 目錄下</li>
<li>.NET Core SDK 開始建立專案所需的檔案</li>
<li>自動 restore dependency</li>
</ol>
<h2 id="使用_VS_Code_開啟專案">使用 VS Code 開啟專案</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">code</span> MyClassLib</span><br></pre></td></tr></table></figure>
<p>使用 <code>code</code> 執行 VS Code，後面接開啟目錄名稱。 </p>
<p><img src="/images/netcore/classlib/lib001.png" alt="ib00"></p>
<ul>
<li>使用 VS Code 開啟 <code>MyClassLib</code></li>
</ul>
<h2 id="編輯_CalculatorService-cs">編輯 CalculatorService.cs</h2><hr>
<p><strong>CalculatorService.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyClassLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>) </span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立 <code>CalculatorService</code>，並有一個 <code>Sum()</code>。</p>
<p><img src="/images/netcore/classlib/lib002.png" alt="ib00"></p>
<ol>
<li>開啟 <code>CalculatorService.cs</code></li>
<li>建立 <code>Sum()</code></li>
</ol>
<h2 id="編譯_Class_Library">編譯 Class Library</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyClassLib $ dotnet <span class="keyword">build </span>-c Release</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet build</code> 是以 <code>Debug</code> 模式編譯，若要以 <code>Release</code> 編譯，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/classlib/lib003.png" alt="ib00"></p>
<ol>
<li>輸入 <code>dotnet build -c Release</code> 以 <code>Release</code> 模式編譯</li>
<li>自動執行 <code>dotnet restore</code></li>
<li>最後 build 出 <code>MyClassLib.dll</code></li>
</ol>
<blockquote>
<p>注意是 build 到 <code>Release</code> 目錄</p>
</blockquote>
<p><strong>使用 MSBuild</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/MyClassLib $ dotnet msbuild /p</span><span class="symbol">:Configuration=Release</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>msbuild</code> 編譯專案。</p>
<p><img src="/images/netcore/classlib/lib004.png" alt="ib00"></p>
<ol>
<li>輸入 <code>dotnet msbuild /p:Configuration=Release</code> 以 <code>Release</code> 模式編譯</li>
<li>最後 build 出 <code>MyClassLib.dll</code></li>
</ol>
<blockquote>
<p>注意使用 MSBuild 時，並沒有執行 <code>dotnet restore</code></p>
</blockquote>
<h2 id="建置_NuGet_Package">建置 NuGet Package</h2><hr>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyClassLib $ dotnet <span class="built_in">pack</span> -c Release</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet pack</code> 將 class library 打包成 Nuget package。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet pack</code> 是以 <code>Debug</code> 模式打包，若要以 <code>Release</code> 打包，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/classlib/lib005.png" alt="ib00"></p>
<ol>
<li>輸入 <code>dotnet pack -c Release</code> 以 <code>Release</code> 模式打包</li>
<li>最後 build 出 <code>MyClassLib.1.0.0.nupkg</code></li>
<li>在 <code>bin/Release/</code> 會看到 <code>MyClassLib.1.0.0.nupkg</code></li>
</ol>
<h2 id="發佈_Class_Library">發佈 Class Library</h2><hr>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">MyClassLib</span> $ <span class="keyword">dotnet</span> publish -c <span class="type">Release</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet publish</code> 將編譯後的 dll 與其 dependency 整理到 <code>publish</code> 目錄，將來只要將此目錄 deploy 到 server 即可。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet publish</code> 是將 <code>Debug</code> 模式的 dll 整理至 <code>publish</code> 目錄，若要整理 <code>Release</code> 模式的的 dll，需要配合 <code>-c</code> 參數</li>
</ul>
<p>![ib00](/images/netcore/classlib</p>
<ol>
<li>輸入 <code>dotnet publish -c Release</code> 將欲 deploy 的檔案整理到 <code>bin/Release/netcoreapp2.0/publish</code> 目錄</li>
<li>我們發現總共有 3 個檔案<ul>
<li><code>MyClassLib.dll</code> : 以 IL 為內容的 assembly</li>
<li><code>MyClassLib.deps.json</code> : 描述執行 dll 所需要的 dependency</li>
<li><code>MyClassLib.pdb</code> : 在 production 環境啟動 debug 時使用</li>
</ul>
</li>
</ol>
<p><strong>使用 MSBuild</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">~/MyClassLib $ dotnet msbuild /</span><span class="string">t:</span>Publish /<span class="string">p:</span>Configuration=Release</span><br></pre></td></tr></table></figure>
<p>使用 <code>msbuild</code> 發佈專案。</p>
<p><img src="/images/netcore/classlib/lib007.png" alt="ib00"></p>
<ol>
<li>輸入 <code>dotnet msbuild /t:Publish /p:Configuration=Release</code> 以 <code>Release</code> 發佈</li>
<li>一樣發布 <code>3</code> 個檔案</li>
</ol>
<blockquote>
<p>注意使用 MSBuild 時，並沒有執行 <code>dotnet restore</code></p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Class library 與 console app 的建置模式並沒有什麼差別，因為 console app 其實也是 dll</li>
<li>一樣可以使用 MSBuild 編譯與發佈 class library，但不會事先執行 <code>dotnet restore</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[使用 .NET Core SDK 建立]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何安裝與移除 Project Template ?]]></title>
    <link href="http://oomusou.io/netcore/project-template/"/>
    <id>http://oomusou.io/netcore/project-template/</id>
    <published>2018-03-16T14:23:43.000Z</published>
    <updated>2018-03-19T02:12:37.070Z</updated>
    <content type="html"><![CDATA[<p>.NET Core SDK 已經內建提供不少 project template，但事實上 .NET Core 官網還提供不少 project template，可自行另外安裝。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="列出所有_Project_Template">列出所有 Project Template</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> -l</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-l</strong> : <code>l</code>ist ，使用 <code>dotnet new</code> 加上 <code>-l</code> 參數，將列出目前系統所安裝的所有 project template。</li>
</ul>
<p><img src="/images/netcore/project-template/sdk001.png" alt="sdk001"></p>
<p>我們可以發現內建的 project template 對 C# 支援最齊全，預設就是 C#，其次是 F#。</p>
<p><img src="/images/netcore/project-template/sdk002.png" alt="sdk001"></p>
<p>事實上在 .NET Core 官網的 <a href="https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new" target="_blank" rel="external">Available templates for dotnet new</a>，還準備了不少其他 project template 可供下載。</p>
<h2 id="安裝_Project_Template">安裝 Project Template</h2><hr>
<p><img src="/images/netcore/project-template/sdk003.png" alt="sdk003"></p>
<p>以 C# 為例，.NET Core 官網亦提供了 <code>AWS Lambda .NET Core Templates</code>，讓我們自動安裝相關工具與 NuGet package。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet new -<span class="tag">i</span> <span class="string">"Amazon.Lambda.Templates::*"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-i</strong> : <code>i</code>nstall，使用 <code>dotnet new -i</code> 安裝新 project template</li>
</ul>
<p><img src="/images/netcore/project-template/sdk004.png" alt="sdk004"></p>
<ol>
<li>輸入 <code>dotnet new -i &quot;Amazon.Lambda.Templates::*&quot;</code> 安裝 <code>Amazon Lambda</code> project template</li>
</ol>
<blockquote>
<p>由於 <code>Amazon Lambda</code> project template 的 NuGet package 較大，安裝要一點時間</p>
</blockquote>
<p><img src="/images/netcore/project-template/sdk005.png" alt="sdk005"></p>
<ol>
<li>安裝完後會自動執行 <code>dotnet new -l</code>，會安裝不少 <code>Amazon Lambda</code> 相關的 project template</li>
</ol>
<h2 id="移除_Project_Template">移除 Project Template</h2><hr>
<p>既然能安裝 project template，也就要能移除 project template，但比較麻煩。</p>
<p>.NET Core SDK 預設將所有的 project template 安裝在 <code>Users/oomusou/.templateengine/dotnetcli/v2.1.101/packages</code> 目錄下。</p>
<blockquote>
<p>其中 <code>oomusou</code> 為 user name</p>
</blockquote>
<p><img src="/images/netcore/project-template/sdk006.png" alt="sdk006"></p>
<ol>
<li><code>amazon.lambda.template.2.0.3.nupkg</code> 為剛剛所安裝的 <code>Amazon Lambda</code> project template</li>
</ol>
<blockquote>
<p>我們可以發現每個 project template 事實上都是 NuGet package</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> -u .../amazon.lambda.templates<span class="number">.2</span><span class="number">.0</span><span class="number">.3</span>.nupkg</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-u</strong> : <code>u</code>ninstall，使用 <code>dotnet new -u</code> 移除已安裝的 project template NuGet package</li>
</ul>
<blockquote>
<p>NuGet package 不可使用 <code>./</code> 方式，但可用完整路徑或 <code>~/</code></p>
</blockquote>
<p><img src="/images/netcore/project-template/sdk007.png" alt="sdk007"></p>
<ol>
<li>輸入 <code>dotnet new -u /Users/…/amazon.lambda.templates.2.0.3.nupkg</code>，必須是完整路徑或 <code>~/</code>，不可為 <code>./</code></li>
</ol>
<p><img src="/images/netcore/project-template/sdk008.png" alt="sdk008"></p>
<ol>
<li><code>Amazon Lambda</code> project template 已順利移除。</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>若想知道 C# 與 F# 還有什麼應用，可上 <a href="https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new" target="_blank" rel="external">Available templates for dotnet new</a> 發現更多有趣的 project template</li>
<li>若要移除 project template，NuGet package 必須使用 <code>完整路徑</code> 或 <code>~/</code>，不可使用 <code>./</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[發現更多有趣的 .NET Core 應用]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探討 dotnet restore]]></title>
    <link href="http://oomusou.io/netcore/restore/"/>
    <id>http://oomusou.io/netcore/restore/</id>
    <published>2018-03-16T14:23:43.000Z</published>
    <updated>2018-03-19T02:12:42.846Z</updated>
    <content type="html"><![CDATA[<p>.NET Core SDK 提供了 <code>dotnet restore</code> 指令，但官網的說明很簡單，只說明了他是 <code>restore dependency</code>，到底什麼是 <code>restore dependency</code> 呢 ?</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101<br>Node.js 8.9.4<br>NPM 5.7.1</p>
<h2 id="NuGet_vs-_NPM">NuGet vs. NPM</h2><hr>
<p>NuGet 與 NPM 都是為了解決 package dependency 的問題</p>
<p>相同之處 :</p>
<ul>
<li><strong>NuGet</strong> : 採用 <code>csproj</code> 紀錄所使用 package</li>
<li><strong>NPM</strong> : 使用 <code>package.json</code> 紀錄所使用 package</li>
</ul>
<p>相異之處 :</p>
<ul>
<li><strong>NuGet</strong> : 將 package 統一放在 <code>~/.nuget/packages</code>，若該 package 有多個版本，則以版本當目錄</li>
<li><strong>NPM</strong> : 多專案共用的 global package 統一放在 <code>/usr/local/lib/node_modules/npm/node_modules</code>，但若專案自己用的 package 則放在專案目錄的 <code>node_modules</code></li>
</ul>
<blockquote>
<p>PHP Composer 哲學與 NPM 類似，也分成 global package 與 local package</p>
</blockquote>
<p><strong>NuGet 優點</strong></p>
<ul>
<li>整個系統只有一份 package，省硬碟空間，而不像 NPM 每個專案都有重複的 package。</li>
</ul>
<p><strong>NuGet 缺點</strong></p>
<ul>
<li>當你刪除專案，系統可能會留著沒用到的 package</li>
<li>必須要有一份 mapping 檔案，讓 compiler 在 build 時，知道 package 放在哪裡，因為 package 不是放在專案目錄下。</li>
</ul>
<p>第 2 點就是 dotnet restore 要解決的。</p>
<h2 id="觀察_Console_App">觀察 Console App</h2><hr>
<p><img src="/images/netcore/restore/restore000.png" alt="estore00"></p>
<ol>
<li>當使用 <code>dotnet new console</code> 時，事實上只是建立了 <code>csproj</code></li>
<li>自動執行 <code>dotnet restore</code>，根據 <code>csproj</code> 建立了 <code>nuget.g.props</code> 與 <code>nuget.g.targets</code></li>
</ol>
<p><img src="/images/netcore/restore/restore001.png" alt="estore00"></p>
<ol>
<li>觀察 <code>nuget.g.props</code>，雖然很多資訊看不懂，但最少看到 <code>&lt;NuGetPackageRoot&gt;</code> 記載著 NuGet 目錄放在 <code>/Users/oomusou/.nuget/packages</code>，這樣 compiler 就可以從這個目錄抓到 NuGet package 放哪裡</li>
</ol>
<blockquote>
<p>之所以沒用 VS Code 開啟專案，是因為 VS Code 還會自動建立其他目錄與檔案，怕模糊焦點，所以這裡選擇 Sublime Text</p>
</blockquote>
<h2 id="刪除_obj_目錄">刪除 obj 目錄</h2><hr>
<p><img src="/images/netcore/restore/restore002.png" alt="estore00"></p>
<ol>
<li>選擇 <code>obj</code> 目錄</li>
<li>刪除 <code>obj</code> 目錄</li>
</ol>
<h2 id="dotnet_restore">dotnet restore</h2><hr>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyProject $ dotnet <span class="built_in">restore</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet restore</code> 重新建立 <code>obj</code> 目錄。</p>
<p><img src="/images/netcore/restore/restore003.png" alt="estore00"></p>
<ol>
<li>輸入 <code>dotnet restore</code></li>
<li>根據 <code>csproj</code> 重新建立 <code>nuget.g.props</code> 與 <code>nuget.g.targets</code> </li>
</ol>
<p><img src="/images/netcore/restore/restore004.png" alt="estore00"></p>
<ol>
<li><code>obj</code> 目錄被 <code>restore</code> 回來了</li>
</ol>
<h2 id="-NET_Core_2-0">.NET Core 2.0</h2><hr>
<p>在 .NET Core 1.x 時代，還常常需要自己下 <code>dotnet restore</code>，但從 .NET Core 2.0 開始，當你使用以下 command 時，都會自動執行 <code>dotnet restore</code>。</p>
<ul>
<li><code>dotnet new</code></li>
<li><code>dotnet build</code></li>
<li><code>dotnet run</code></li>
<li><code>dotnet test</code></li>
<li><code>dotnet publish</code></li>
<li><code>dotnet pack</code></li>
</ul>
<p>所以在實務上已經幾乎不用自己下 <code>dotnet restore</code> 了，只要有觀念即可，為了相容，目前 .NET Core SDK 還是有留下 <code>dotnet restore</code> 指令。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li><code>dotnet restore</code> 是根據 <code>csproj</code> 建立 package 與實際位置的 mapping 檔案</li>
<li>.NET Core 2 之後幾乎不用再自己下 <code>dotnet restore</code> 指令，只要有觀念即可</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[NuGet 特有的管理機制]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET Core SDK 基本指令練習]]></title>
    <link href="http://oomusou.io/netcore/basic-sdk/"/>
    <id>http://oomusou.io/netcore/basic-sdk/</id>
    <published>2018-03-16T13:23:43.000Z</published>
    <updated>2018-03-19T02:07:33.283Z</updated>
    <content type="html"><![CDATA[<p>Console app 是最基本的 .NET Core 專案類型，常用在測試 class library、提供 class library 範例程式，或者開發跨平台的 CLI 工具，我們可以使用 <code>ng new console</code> 建立 console app 型態專案。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="建立_Console_App_專案">建立 Console App 專案</h2><hr>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> <span class="built_in">console</span> -o MyConsole</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new</code> 建立專案。</p>
<ul>
<li><strong>console</strong> : 建立 console 類型專案</li>
<li><strong>-o</strong> : <code>o</code> output，建立在 <code>MyConsole</code> 目錄下</li>
</ul>
<p><img src="/images/netcore/basic-sdk/sdk009.png" alt="sdk009"></p>
<ol>
<li>輸入 <code>dotnet new console -o MyConsole</code> 將 console 類型專案建立在 <code>MyConsole</code> 目錄下</li>
<li>.NET Core SDK 開始建立專案所需的檔案</li>
<li>自動 restore dependency</li>
</ol>
<h2 id="使用_VS_Code_開啟專案">使用 VS Code 開啟專案</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">code</span> MyConsole</span><br></pre></td></tr></table></figure>
<p>使用 <code>code</code> 執行 VS Code，後面接開啟目錄名稱。</p>
<p><img src="/images/netcore/basic-sdk/sdk010.png" alt="sdk010"></p>
<ol>
<li>第一次使用 VS Code 開啟 .NET Core 專案，會要求建立 <code>.vscode</code> 設定檔目錄，按 <code>Yes</code> 繼續</li>
</ol>
<p><img src="/images/netcore/basic-sdk/sdk011.png" alt="sdk011"></p>
<ol>
<li><code>.vscode</code> 被 VS Code 自動建立</li>
</ol>
<h2 id="編輯_Program-cs">編輯 Program.cs</h2><hr>
<p><img src="/images/netcore/basic-sdk/sdk012.png" alt="sdk012"></p>
<ol>
<li>開啟 <code>Program.cs</code></li>
<li>將 <code>World</code> 改成 <code>Sam</code> 存檔</li>
</ol>
<h2 id="觀察_MyConsole-csproj">觀察 MyConsole.csproj</h2><hr>
<p><img src="/images/netcore/basic-sdk/sdk013.png" alt="sdk013"></p>
<ol>
<li>開啟 <code>MyConsole.csproj</code></li>
</ol>
<blockquote>
<p><code>csproj</code> 負責紀錄 project 的 project 與 package 的 reference ，以及其他與 project 相關資訊，使用 Visual Studio 配合 .NET Framework 時，我們不會去維護 <code>csproj</code> 檔案，而是靠 Visual Studio 幫我們維護，但若使用 VS Code + .NET Core CLI 的組合時，將來會有很多機會要自己維護 <code>csproj</code></p>
</blockquote>
<h2 id="還原_Dependency">還原 Dependency</h2><hr>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyConsole $ dotnet <span class="built_in">restore</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet restore</code> 根據 <code>csproj</code> 建立 package 與實際位置的 mapping 檔案。</p>
<p><img src="/images/netcore/basic-sdk/sdk014.png" alt="sdk014"></p>
<ol>
<li>按熱鍵 Ctrl + ` 開啟內建的 terminal</li>
<li>輸入 <code>dotnet restore</code> 還原 dependency</li>
</ol>
<h2 id="編譯_Console_App">編譯 Console App</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyConsole $ dotnet <span class="keyword">build </span>-c Release</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet build</code> 是以 <code>Debug</code> 模式編譯，若要以 <code>Release</code> 編譯，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/basic-sdk/sdk000.png" alt="dk00"></p>
<ol>
<li>輸入 <code>dotnet build -c Release</code> 以 <code>Release</code> 模式編譯</li>
<li>自動執行 <code>dotnet restore</code></li>
<li>最後 build 出 <code>MyConsole.dll</code></li>
</ol>
<blockquote>
<p>注意是 build 到 <code>Release</code> 目錄</p>
</blockquote>
<h2 id="執行_Console_App">執行 Console App</h2><hr>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/MyConsole $ dotnet <span class="command">run</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet run</code> 執行專案。</p>
<blockquote>
<p><code>dotnet run</code> 明顯感覺比較慢，因為 C# 不是 script，<code>dotnet run</code> 事實上做了幾件事情 :</p>
<ol>
<li><code>dotnet restore</code></li>
<li><code>dotnet build</code></li>
<li>最後才是執行程式</li>
</ol>
<p>所以才會感覺比較慢</p>
</blockquote>
<p><img src="/images/netcore/basic-sdk/sdk001.png" alt="dk00"></p>
<ol>
<li>輸入 <code>dotnet run</code> 顯示執行結果</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">~/MyConsole $ dotnet /</span>Users<span class="regexp">/oomusou/</span>Code<span class="regexp">/CSharp/</span>MyConsole<span class="regexp">/bin/</span>Release/netcoreapp2.</span><br><span class="line"><span class="number">0</span>/MyConsole.dll</span><br></pre></td></tr></table></figure>
<p>直接使用 <code>dontet</code> 執行 dll，由於使用 <code>Release</code> 模式編譯，速度非常快。</p>
<p><img src="/images/netcore/basic-sdk/sdk002.png" alt="dk00"></p>
<ol>
<li>輸入 <code>dotnet</code> 直接執行編譯過 <code>Release</code> 模式的 <code>MyConsole.dll</code></li>
<li>馬上出現 <code>Hello Sam!</code> ，不用等待</li>
</ol>
<blockquote>
<p>實務上不建議直接使用 <code>dotnet run</code>，因為速度很慢，要用 <code>dotnet</code> 執行編譯過且最佳化的 dll</p>
</blockquote>
<h2 id="清除_Assembly">清除 Assembly</h2><hr>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">MyConsole</span> $ <span class="keyword">dotnet</span> clean -c <span class="type">Release</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet clean</code> 清除所編譯的 dll。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet clean</code> 是清除 <code>Debug</code> 模式的 dll，若要清除 <code>Release</code> 模式的的 dll，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/basic-sdk/sdk003.png" alt="dk00"></p>
<ol>
<li>輸入 <code>dotnet clean -c Release</code> 清除以 <code>Release</code> 模式 build 的 <code>MyConsole.dll</code></li>
<li>查看 <code>bin/Release/netcoreapp2.0</code> 目錄，確認所有檔案已經清除</li>
</ol>
<h2 id="發佈_Console_App">發佈 Console App</h2><hr>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">MyConsole</span> $ <span class="keyword">dotnet</span> publish -c <span class="type">Release</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet publish</code> 將編譯後的 dll 與其 dependency 整理到 <code>publish</code> 目錄，將來只要將此目錄 deploy 到 server 即可。</p>
<ul>
<li><strong>-c</strong> : <code>c</code>onfiguration，預設 <code>dotnet publish</code> 是將 <code>Debug</code> 模式的 dll 整理至 <code>publish</code> 目錄，若要整理 <code>Release</code> 模式的的 dll，需要配合 <code>-c</code> 參數</li>
</ul>
<p><img src="/images/netcore/basic-sdk/sdk004.png" alt="dk00"></p>
<ol>
<li>輸入 <code>dotnet publish -c Release</code> 將欲 deploy 的檔案整理到 <code>bin/Release/netcoreapp2.0/publish</code> 目錄</li>
<li>在 <code>publish</code> 目錄下，我們總共發現有 4 個檔案<ul>
<li><code>MyConsole.dll</code> : 以 IL 為內容的 assembly</li>
<li><code>MyConsole.deps.json</code> : 描述執行 dll 所需要的 dependency</li>
<li><code>MyConsole.runtimeconfig.json</code> : 描述 dll 所需要的 .NET Core runtime 版本，以及其他 runtime 設定 (Ex. Garbage Collection 方式)</li>
<li><code>MyConsole.pdb</code> : 在 production 環境啟動 debug 時使用</li>
</ul>
</li>
</ol>
<h2 id="執行_Console_App-1">執行 Console App</h2><hr>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/MyProject $ dotnet bin/</span>Release<span class="regexp">/netcoreapp2.0/</span>publish<span class="regexp">/MyConsole.dll</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet</code> 執行 publish 後的 dll。</p>
<p><img src="/images/netcore/basic-sdk/sdk005.png" alt="dk00"></p>
<ol>
<li>輸入 <code>dotnet</code> 直接執行  publish 過的 <code>MyConsole.dll</code></li>
<li>馬上出現 <code>Hello Sam!</code> ，不用等待</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>藉由 <code>Hello World</code> 練習最基本的 .NET Core SDK 指令</li>
<li><code>dotnet run</code> 因為要執行 <code>dotnet restore</code> 、<code>dotnet build</code> ，所以執行速度較慢</li>
<li><code>dotnet publish</code> 會幫我們將 dependency 加以整理，方便 deployment</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[天天都會用到的 .NET Core 指令]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[F# 語法檢定考]]></title>
    <link href="http://oomusou.io/fsharp/syntax-all/"/>
    <id>http://oomusou.io/fsharp/syntax-all/</id>
    <published>2018-03-16T12:23:43.000Z</published>
    <updated>2018-03-14T07:57:49.606Z</updated>
    <content type="html"><![CDATA[<p>F# 的語法雖然很精簡，但還是得稍微花時間學習，Scott Wlaschin 所寫的這份 code，幾乎包含 F# 的所有語法，若都看得懂，F# 語法部分就算過關了。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>F# 4.1</p>
<h2 id="Overview_of_F#_Syntax">Overview of F# Syntax</h2><hr>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is presented with permission from Scott Wlaschin, the original author.  This has been slightly modified.</span></span><br><span class="line"><span class="comment">// Single line comments use a double slash.</span></span><br><span class="line"><span class="comment">(* </span><br><span class="line">    Multi-line comments can be done this way (though double-slash is usually used).</span><br><span class="line">*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== "Variables" (but not really) ==========</span></span><br><span class="line"><span class="comment">// The "let" keyword defines an (immutable) value</span></span><br><span class="line"><span class="keyword">let</span> myInt = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> myFloat = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="string">"hello"</span>   <span class="comment">// note that no types needed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== Lists ============</span></span><br><span class="line"><span class="keyword">let</span> twoToFive = [ <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span> ]        <span class="comment">// Square brackets create a list with</span></span><br><span class="line">                                     <span class="comment">// semicolon delimiters.</span></span><br><span class="line"><span class="keyword">let</span> oneToFive = <span class="number">1</span> :: twoToFive   <span class="comment">// :: creates list with new 1st element</span></span><br><span class="line"><span class="comment">// The result is [1; 2; 3; 4; 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zeroToFive = [<span class="number">0</span>;<span class="number">1</span>] @ twoToFive   <span class="comment">// @ concats two lists</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPORTANT: commas are never used as delimiters, only semicolons!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== Functions ========</span></span><br><span class="line"><span class="comment">// The "let" keyword also defines a named function.</span></span><br><span class="line"><span class="keyword">let</span> square x = x * x          <span class="comment">// Note that no parens are used.</span></span><br><span class="line">square <span class="number">3</span>                      <span class="comment">// Now run the function. Again, no parens.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add x y = x + y           <span class="comment">// don't use add (x,y)! It means something</span></span><br><span class="line">                              <span class="comment">// completely different.</span></span><br><span class="line">add <span class="number">2</span> <span class="number">3</span>                       <span class="comment">// Now run the function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// to define a multiline function, just use indents. No semicolons needed.</span></span><br><span class="line"><span class="keyword">let</span> evens list =</span><br><span class="line">   <span class="keyword">let</span> isEven x = x % <span class="number">2</span> = <span class="number">0</span>     <span class="comment">// Define "isEven" as an inner ("nested") function</span></span><br><span class="line">   List.filter isEven list      <span class="comment">// List.filter is a library function</span></span><br><span class="line">                                <span class="comment">// with two parameters: a boolean function</span></span><br><span class="line">                                <span class="comment">// and a list to work on</span></span><br><span class="line">  </span><br><span class="line">evens oneToFive               <span class="comment">// Now run the function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can use parens to clarify precedence. In this example,</span></span><br><span class="line"><span class="comment">// do "map" first, with two args, then do "sum" on the result.</span></span><br><span class="line"><span class="comment">// Without the parens, "List.map" would be passed as an arg to List.sum</span></span><br><span class="line"><span class="keyword">let</span> sumOfSquaresTo100 =</span><br><span class="line">   List.sum (List.map square [ <span class="number">1</span> .. <span class="number">100</span> ])</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can pipe the output of one operation to the next using "|&gt;"</span></span><br><span class="line"><span class="comment">// Here is the same sumOfSquares function written using pipes</span></span><br><span class="line"><span class="keyword">let</span> sumOfSquaresTo100piped =</span><br><span class="line">   [ <span class="number">1</span> .. <span class="number">100</span> ] |&gt; List.map square |&gt; List.sum  <span class="comment">// "square" was defined earlier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can define lambdas (anonymous functions) using the "fun" keyword</span></span><br><span class="line"><span class="keyword">let</span> sumOfSquaresTo100withFun =</span><br><span class="line">   [ <span class="number">1</span> .. <span class="number">100</span> ] |&gt; List.map (<span class="keyword">fun</span> x -&gt; x * x) |&gt; List.sum</span><br><span class="line"></span><br><span class="line"><span class="comment">// In F# returns are implicit -- no "return" needed. A function always</span></span><br><span class="line"><span class="comment">// returns the value of the last expression used.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======== Pattern Matching ========</span></span><br><span class="line"><span class="comment">// Match..with.. is a supercharged case/switch statement.</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">match</span> x <span class="keyword">with</span></span><br><span class="line">| <span class="string">"a"</span> -&gt; printfn <span class="string">"x is a"</span></span><br><span class="line">| <span class="string">"b"</span> -&gt; printfn <span class="string">"x is b"</span></span><br><span class="line">| _ -&gt; printfn <span class="string">"x is something else"</span>   <span class="comment">// underscore matches anything</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some(..) and None are roughly analogous to Nullable wrappers</span></span><br><span class="line"><span class="keyword">let</span> validValue = Some(<span class="number">99</span>)</span><br><span class="line"><span class="keyword">let</span> invalidValue = None</span><br><span class="line"></span><br><span class="line"><span class="comment">// In this example, match..with matches the "Some" and the "None",</span></span><br><span class="line"><span class="comment">// and also unpacks the value in the "Some" at the same time.</span></span><br><span class="line"><span class="keyword">let</span> optionPatternMatch input =</span><br><span class="line">   <span class="keyword">match</span> input <span class="keyword">with</span></span><br><span class="line">    | Some i -&gt; printfn <span class="string">"input is an int=%d"</span> i</span><br><span class="line">    | None -&gt; printfn <span class="string">"input is missing"</span></span><br><span class="line"></span><br><span class="line">optionPatternMatch validValue</span><br><span class="line">optionPatternMatch invalidValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= Complex Data Types =========</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tuple types are pairs, triples, etc. Tuples use commas.</span></span><br><span class="line"><span class="keyword">let</span> twoTuple = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> threeTuple = (<span class="string">"a"</span>, <span class="number">2</span>, <span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record types have named fields. Semicolons are separators.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Person</span> </span>= &#123; First: string; Last: string &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123; First=<span class="string">"John"</span>; Last=<span class="string">"Doe"</span> &#125;</span><br><span class="line"><span class="comment">// You can also use new lines to elide the semiclon.</span></span><br><span class="line"><span class="keyword">let</span> person2 =</span><br><span class="line">    &#123; First=<span class="string">"Jane"</span></span><br><span class="line">      Last=<span class="string">"Doe"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union types have choices. Vertical bars are separators.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Temp</span> </span>= </span><br><span class="line">    | DegreesC <span class="keyword">of</span> float</span><br><span class="line">    | DegreesF <span class="keyword">of</span> float</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = DegreesF <span class="number">98.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Types can be combined recursively in complex ways.</span></span><br><span class="line"><span class="comment">// E.g. here is a union type that contains a list of the same type:</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Employee</span> </span>= </span><br><span class="line">  | Worker <span class="keyword">of</span> Person</span><br><span class="line">  | Manager <span class="keyword">of</span> Employee list</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jdoe = &#123; First=<span class="string">"John"</span>; Last=<span class="string">"Doe"</span> &#125;</span><br><span class="line"><span class="keyword">let</span> worker = Worker jdoe</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= Printing =========</span></span><br><span class="line"><span class="comment">// The printf/printfn functions are similar to the</span></span><br><span class="line"><span class="comment">// Console.Write/WriteLine functions in C#.</span></span><br><span class="line">printfn <span class="string">"Printing an int %i, a float %f, a bool %b"</span> <span class="number">1</span> <span class="number">2.0</span> <span class="keyword">true</span></span><br><span class="line">printfn <span class="string">"A string %s, and something generic %A"</span> <span class="string">"hello"</span> [ <span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// all complex types have pretty printing built in</span></span><br><span class="line">printfn <span class="string">"twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A"</span> </span><br><span class="line">         twoTuple person1 temp worker</span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://blogs.msdn.microsoft.com/dotnet/" target="_blank" rel="external">.NET Blog</a>, <a href="https://blogs.msdn.microsoft.com/dotnet/2017/07/24/get-started-with-f-as-a-c-developer/" target="_blank" rel="external">Get Started with F# as a C# developer</a></p>
]]></content>
    <summary type="html">
    <![CDATA[一段 code 幾乎包含 F# 所有語法]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
      <category term="F#" scheme="http://oomusou.io/tags/F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET Core SDK 簡介]]></title>
    <link href="http://oomusou.io/netcore/sdk/"/>
    <id>http://oomusou.io/netcore/sdk/</id>
    <published>2018-03-16T12:23:43.000Z</published>
    <updated>2018-03-19T02:12:51.294Z</updated>
    <content type="html"><![CDATA[<p>.NET Core 為了要跨平台，在 .NET Core SDK 提供了全套的 CLI，讓我們可以完全用 command 方式管理專案。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>.NET Core SDK 2.1.101</p>
<h2 id="為什麼要用_Command_?">為什麼要用 Command ?</h2><hr>
<p>傳統 .NET Framework 都是在 Visual Studio 以 GUI 方式操作，GUI 對 End User 是友善的，但對 Developer 與 DevOps 而言卻不見得友善 :</p>
<ol>
<li>GUI 很難自動化，但 command 很適合寫 script 自動化，而且可以 git 版控</li>
<li>若要遠端管理 server，GUI 只能透過 Remote Desktop，但 command 只要 SSH 就可執行</li>
<li>Command 可以寫在 Dockerfile 內，但 GUI 無法</li>
<li>.NET Core 最新功能會先在 SDK 支援，Visual Studio 支援稍慢於 SDK</li>
<li>Command 適合在 macOS 與 Linux 執行</li>
</ol>
<p>這也是為什麼目前潮流是 End User 與 Designer 使用 GUI，但 Developer 與 DevOps 使用 command。</p>
<p>.NET Core 全部的動作都可以使用 command 執行。</p>
<blockquote>
<p>就類似學 Git 要從 command 開始學，只要原理懂，自然會使用 Visual Studio / Rider 的 GUI </p>
</blockquote>
<h2 id="-NET_Core_SDK_Command">.NET Core SDK Command</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>列出全部 .NET Core SDK 指令的說明。</p>
<p><img src="/images/netcore/sdk/sdk000.png" alt="sdk000"></p>
<ul>
<li><strong>dotnet help</strong> : 顯示所有 command 與 option 的文件</li>
<li><strong>dotnet new</strong> : 根據指定 template 建立 project</li>
<li><strong>dotnet restore</strong> : 根據  <code>*.csproj</code> 的資訊 restore dependency</li>
<li><strong>dotnet run</strong> : 執行 .NET Core 應用程式</li>
<li><strong>dotnet build</strong> : 編譯 .NET Core 應用程式為 assembly (dll)</li>
<li><strong>dotnet publish</strong> : 發布 .NET Core 應用程式</li>
<li><strong>dotnet test</strong> : 執行 .NET Core 單元測試</li>
<li><strong>dotnet pack</strong> : 建立 NuGet package</li>
<li><strong>dotnet migrate</strong> : 將 project.json 專案升級到 msbuild 專案</li>
<li><strong>dotnet clean</strong> : 將之前編譯的 assembly (dll) 刪除</li>
<li><strong>dotnet sln</strong> : 管理 solution 檔</li>
<li><strong>dotnet add</strong> : 新增 project reference 或 package reference</li>
<li><strong>dotnet remove</strong> : 移除 project reference 與 package reference</li>
<li><strong>dotnet list</strong> : 列出 project 所有的 reference</li>
<li><strong>dotnet nuget</strong> : 執行 NuGet command</li>
<li><strong>dotnet msbuild</strong> : 執行 MSBuild</li>
<li><strong>dotnet vstest</strong> : 對 assembly 執行單元測試</li>
</ul>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>透過 .NET Core SDK，我們可以完全使用 command 的方式管理專案，完全不需要 GUI</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[完全以 command 方式管理 .NET Core]]>
    
    </summary>
    
      <category term=".NET Core" scheme="http://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 macOS 輕鬆使用 Visual Studio 熱鍵?]]></title>
    <link href="http://oomusou.io/vs/shortcut/"/>
    <id>http://oomusou.io/vs/shortcut/</id>
    <published>2018-03-15T12:23:43.000Z</published>
    <updated>2018-03-13T14:46:57.172Z</updated>
    <content type="html"><![CDATA[<p>只要安裝了 Parallel Desktop，就可以在 macOS 執行 Windows 10 與 Visual Studio，但一些 Visual Studio 的熱鍵會先被 macOS 攔截，且 mac 鍵盤又天生沒有 Home / End / Page Down / Page Up，再加上 Touch Bar 之後，我們會希望盡量不要用到 <code>F1 ~ F12</code>，在種種條件下， 我們該如何在 macOS 上高效率的使用 Visual Studio 呢 ?</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.3<br>Parallel Desktop 13 for Mac Pro Edition 13.3.0 (43321)<br>Windows 10 Pro 1709 16299.251<br>Visual Studio 2017 15.5.7</p>
<h2 id="Home">Home</h2><hr>
<p>Visual Studio 熱鍵眾多，在此先針對最常用的熱鍵處理，只要學會方法，可自行舉一反三。</p>
<p><img src="/images/vs/shortcut/shortcut000.png" alt="shortcut000"></p>
<ol>
<li>選擇要設定的 VM</li>
<li>按滑鼠右鍵選 <code>Configure…</code></li>
</ol>
<p><img src="/images/vs/shortcut/shortcut001.png" alt="shortcut001"></p>
<ol>
<li>選 <code>Hardware</code></li>
<li>選 <code>Mouse &amp; Keyboard</code></li>
<li>按下 <code>Open Shortcuts Preferences…</code></li>
</ol>
<p><img src="/images/vs/shortcut/shortcut002.png" alt="shortcut002"></p>
<ol>
<li>選擇你要設定的 VM</li>
<li><strong>Profile</strong> : 選擇 Widnows，Parallel Desktop 預設已經幫我們根據 macOS 的習慣，預先設定了相對應的 Windows shortcut mapping</li>
<li>若你修改了 mapping 之後不滿意，可以隨是按下 <code>Restore Defaults</code> 回到 Parallel Desktop 預設所提供的 shortcut mapping</li>
<li>按下 <code>+</code> 新增 shortcut : 雖然已經內建一下 shortcut mapping，但對於 Visual Studio 的使用仍然不足，我們必須自行增加 mapping</li>
</ol>
<p><img src="/images/vs/shortcut/shortcut003.png" alt="shortcut003"></p>
<p>根據 macOS 的習慣，<code>⌘ + ←</code> 相當於 Windows 的 <code>Home</code>。</p>
<ol>
<li><code>From</code> ：設定 macOS 的 shortcut，</li>
<li><code>To</code> ：設定 Windows 的 shortcut。</li>
</ol>
<blockquote>
<p>因為 Mac 鍵盤沒有 <code>Home</code>，可用下拉選單選擇 <code>Home</code> ，或者輸入 <code>fn + ←</code></p>
</blockquote>
<h2 id="End">End</h2><hr>
<p><img src="/images/vs/shortcut/shortcut004.png" alt="shortcut004"></p>
<p>根據 macOS 的習慣，<code>⌘ + →</code> 相當於 Windows 的 <code>End</code>。</p>
<h2 id="Page_Up">Page Up</h2><hr>
<p><img src="/images/vs/shortcut/shortcut005.png" alt="shortcut005"></p>
<p>根據 macOS 的習慣，<code>⌘ + ↑</code> 相當於 Windows 的 <code>Page Up</code>。</p>
<h2 id="Page_Down">Page Down</h2><hr>
<p><img src="/images/vs/shortcut/shortcut006.png" alt="shortcut006"></p>
<p>根據 macOS 的習慣，<code>⌘ + ↓</code> 相當於 Windows 的 <code>Page Down</code>。</p>
<h2 id="Shift_+_Home">Shift + Home</h2><hr>
<p><img src="/images/vs/shortcut/shortcut007.png" alt="shortcut007"></p>
<p>根據 macOS 的習慣，<code>⇧ + ⌘ + ←</code> 相當於 Windows 的 <code>Shift + Home</code>。</p>
<h2 id="Shift_+_End">Shift + End</h2><hr>
<p><img src="/images/vs/shortcut/shortcut008.png" alt="shortcut008"></p>
<p>根據 macOS 的習慣，<code>⇧ + ⌘ + →</code> 相當於 Windows 的 <code>Shift + End</code>。</p>
<h2 id="Delete_Line">Delete Line</h2><hr>
<p><img src="/images/vs/shortcut/shortcut009.png" alt="shortcut009"></p>
<p>根據 JetBrains 習慣，<code>⌘ + ⌦</code> 相當於 Delete Line，這在 Visual Studio 對應的熱鍵為 <code>Ctrl + Shift + L</code>。</p>
<h2 id="Start_Without_Debugging">Start Without Debugging</h2><hr>
<p><code>Start without Debugging</code> 也是 Visual Studio 常用的熱鍵，但預設是 <code>Ctrl + F5</code>，對於 macOS 而言，一般我們不會用到 <code>F1 ~ F12</code>，而是將這些熱鍵讓給 Touch Bar，所以建議更改 Visual Studio 熱鍵。</p>
<p>將 <code>⇧ + ⌥ + R</code> 設定為 Start without Debugging。</p>
<p><img src="/images/vs/shortcut/shortcut010.png" alt="shortcut010"></p>
<p><strong><em>Tools -&gt; Options</em></strong></p>
<p><img src="/images/vs/shortcut/shortcut011.png" alt="shortcut011"></p>
<ol>
<li>選擇 <code>keyboard</code></li>
<li><code>Show commands containing</code> 輸入 <code>Debug.Start</code></li>
<li>選擇 <code>Debug.StartWithoutDebugging</code></li>
<li>新增 <code>Shift + Alt + R</code> 熱鍵</li>
</ol>
<h2 id="Start_Debugging">Start Debugging</h2><hr>
<p><code>Start Debugging</code> 也是 Visual Studio 常用的熱鍵，但預設是 <code>F5</code>，我們一樣希望 <code>F1 ~ F12</code> 讓給 Touch Bar，所以建議更改 Visual Studio 熱鍵。</p>
<p>將 <code>⇧ + ⌥ + D</code> 設定為 Start Debugging。</p>
<p><img src="/images/vs/shortcut/shortcut012.png" alt="shortcut012"></p>
<ol>
<li>選擇 <code>keyboard</code></li>
<li><code>Show commands containing</code> 輸入 <code>Debug.Start</code></li>
<li>選擇 <code>Debug.Start</code></li>
<li>新增 <code>Shift + Alt + D</code> 熱鍵</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>若是熱鍵被 macOS 攔截，可在 Parallel Desktop 設定 shortcut mapping</li>
<li>若是 Visual Studio 的預設熱鍵不滿意，可在 <code>Tools -&gt; Options</code> 重新設定熱鍵</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[重新設定 Parallel Desktop 與 Visual Studio 的 shortcut mapping]]>
    
    </summary>
    
      <category term="Parallel Desktop" scheme="http://oomusou.io/tags/Parallel-Desktop/"/>
    
      <category term="Visual Studio" scheme="http://oomusou.io/tags/Visual-Studio/"/>
    
      <category term="macOS" scheme="http://oomusou.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 .NET Framework 使用有 FIFO 的 AWS SQS ?]]></title>
    <link href="http://oomusou.io/aws/sqs/"/>
    <id>http://oomusou.io/aws/sqs/</id>
    <published>2018-03-14T12:23:43.000Z</published>
    <updated>2018-03-14T01:36:17.766Z</updated>
    <content type="html"><![CDATA[<p>在非同步的資料處理當中，Queue 是常見的應用，本文使用 .NET Framework + AWS Toolkit for Visual Studio 控制有 FIFO 的 AWS SQS。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>Windows 10 Pro 1709 16299.251<br>.NET Framework 4.6.2<br>Visual Studio 2017 15.5.7<br>AWS Toolkit for Visual Studio</p>
<h2 id="安裝_AWS_Toolkit_for_Visual_Studio">安裝 AWS Toolkit for Visual Studio</h2><hr>
<p><img src="/images/aws/sqs/sqs001.png" alt="sqs001"></p>
<ol>
<li>到 AWS 官網下載 <a href="https://aws.amazon.com/visualstudio/" target="_blank" rel="external">AWS Toolkit for Visual Studio</a></li>
<li>選擇 <code>AWS Toolkit for Visual Studio 2017</code></li>
</ol>
<p><img src="/images/aws/sqs/sqs002.png" alt="sqs002"></p>
<ol>
<li>按 <code>Download</code> 開始下載</li>
</ol>
<p><img src="/images/aws/sqs/sqs003.png" alt="sqs003"></p>
<ol>
<li><code>AWSToolkitPackage.vsix</code> 會下載到 <code>Downloads</code> 目錄下</li>
<li>執行 <code>AWSToolkitPackage</code> 安裝 AWS Toolkit for Visual Studio</li>
</ol>
<p><img src="/images/aws/sqs/sqs004.png" alt="sqs004"></p>
<p>安裝完成後，重新啟動 Visual Studio 2017 就會出現 <code>AWS Getting Started</code> 首頁。</p>
<h2 id="建立_Project">建立 Project</h2><hr>
<p><img src="/images/aws/sqs/sqs005.png" alt="sqs005"></p>
<p><strong><em>File -&gt; New Project</em></strong></p>
<p><strong><em>Visual C# -&gt; AWS Samples -&gt; App Services -&gt; AWS SQS Sample</em></strong></p>
<p><img src="/images/aws/sqs/sqs006.png" alt="sqs006"></p>
<p>第一次建立專案時，會要求你建立 <code>Account Profile</code> 與 <code>Region</code>。</p>
<ol>
<li>按 <code>+</code> 新增</li>
</ol>
<p><img src="/images/aws/sqs/sqs007.png" alt="sqs007"></p>
<ol>
<li>輸入 <code>Access Key ID</code> 與 <code>Secret Access Key</code></li>
</ol>
<p><img src="/images/aws/sqs/sqs008.png" alt="sqs008"></p>
<ol>
<li>會自動選擇美西的 server</li>
</ol>
<blockquote>
<p>AWS 並不是所有的 SQS 都支援 FIFO，如東京的 server 的 SQS 就不支援 FIFO</p>
</blockquote>
<h2 id="寫入_Message_進_Queue">寫入 Message 進 Queue</h2><hr>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Amazon.SQS;</span><br><span class="line"><span class="keyword">using</span> Amazon.SQS.Model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SQSSendMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// SQSClient from AWSSDK</span></span><br><span class="line">            <span class="keyword">var</span> amazonSqsClient = <span class="keyword">new</span> AmazonSQSClient();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIFO quene URL</span></span><br><span class="line">            <span class="keyword">string</span> myQueueUrl = <span class="string">"https://sqs.us-west-2.amazonaws.com/781160412246/ecfe.fifo"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Send 3 messages to FIFO queue</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> message = <span class="string">"message"</span> + i;</span><br><span class="line">                    <span class="keyword">var</span> sendMessageRequest = <span class="keyword">new</span> SendMessageRequest</span><br><span class="line">                    &#123;</span><br><span class="line">                        QueueUrl = myQueueUrl,</span><br><span class="line">                        MessageBody = message,</span><br><span class="line">                        MessageGroupId = <span class="string">"Senao"</span></span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    amazonSqsClient.SendMessage(sendMessageRequest);</span><br><span class="line">                    Console.WriteLine(<span class="string">"Send message &#123;0&#125;"</span>, message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AmazonSQSException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Caught Exception: "</span> + ex.Message);</span><br><span class="line">                Console.WriteLine(<span class="string">"Response Status Code: "</span> + ex.StatusCode);</span><br><span class="line">                Console.WriteLine(<span class="string">"Error Code: "</span> + ex.ErrorCode);</span><br><span class="line">                Console.WriteLine(<span class="string">"Error Type: "</span> + ex.ErrorType);</span><br><span class="line">                Console.WriteLine(<span class="string">"Request ID: "</span> + ex.RequestId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"Press Enter to continue..."</span>);</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQSClient from AWSSDK</span></span><br><span class="line"><span class="keyword">var</span> amazonSqsClient = <span class="keyword">new</span> AmazonSQSClient();</span><br></pre></td></tr></table></figure>
<p>要使用 SQS，首先要建立 <code>AmazonSQSClient</code> 物件，所有的操作都從 <code>AmazonSQSClient</code> 開始。</p>
<p>14 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FIFO quene URL</span></span><br><span class="line"><span class="keyword">string</span> myQueueUrl = <span class="string">"https://sqs.us-west-2.amazonaws.com/781160412246/ecfe.fifo"</span>;</span><br></pre></td></tr></table></figure>
<p>無論是 <code>寫入 message</code>、<code>讀出 message</code> 或者 <code>刪除 message</code>，都必須靠 <code>QueueUrl</code> 辨識你所要控制的 queue。</p>
<p>23 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sendMessageRequest = <span class="keyword">new</span> SendMessageRequest</span><br><span class="line">&#123;</span><br><span class="line">    QueueUrl = myQueueUrl,</span><br><span class="line">    MessageBody = message,</span><br><span class="line">    MessageGroupId = <span class="string">"oomusou"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">amazonSqsClient.SendMessage(sendMessageRequest);</span><br><span class="line">Console.WriteLine(<span class="string">"Send message &#123;0&#125;"</span>, message);</span><br></pre></td></tr></table></figure>
<p>建立 <code>SendMessageRequest</code> DTO，其中 <code>QueueUrl</code> 為 queue 的 URL；而 <code>MessageBody</code> 為要傳入 queue 的內容。</p>
<blockquote>
<p>FIFO queue 與 Standard queue 最大的差別在於 <code>MessageGroupId</code>，根據 AWS 文件，只有相同的 <code>MessageGroupId</code> 才能使用 FIFO queue，並保證 message 會 <code>先進先出</code>，若沒指定 <code>MessageGroupId</code> 則視為 Standard Queue，並不保證 message 會 <code>先進先出</code>。</p>
</blockquote>
<p>再將 <code>SendMessageRequest</code> DTO 傳入 <code>AmazonSQSClient.SendMessage()</code>，正式將資料寫入 queue。</p>
<h2 id="從_Queue_讀出_Message">從 Queue 讀出 Message</h2><hr>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Amazon;</span><br><span class="line"><span class="keyword">using</span> Amazon.SQS;</span><br><span class="line"><span class="keyword">using</span> Amazon.SQS.Model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SQSReceiveMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// SQSClient from AWSSDK</span></span><br><span class="line">            <span class="keyword">var</span> amazonSqsClient = <span class="keyword">new</span> AmazonSQSClient();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIFO quene URL</span></span><br><span class="line">            <span class="keyword">string</span> myQueueUrl = <span class="string">"https://sqs.us-west-2.amazonaws.com/781160412246/ecfe.fifo"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Send 3 messages to FIFO queue</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Read message from FIFO queue</span></span><br><span class="line">                    <span class="keyword">var</span> receiveMessageRequest = <span class="keyword">new</span> ReceiveMessageRequest</span><br><span class="line">                    &#123;</span><br><span class="line">                        QueueUrl = myQueueUrl</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> receiveMessageResponse = amazonSqsClient.ReceiveMessage(receiveMessageRequest);</span><br><span class="line">                    <span class="keyword">if</span> (receiveMessageResponse.Messages != <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> message = receiveMessageResponse.Messages[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(message.Body))</span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(<span class="string">"Read message: &#123;0&#125;"</span>, message.Body);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Delete message from FIFO queue</span></span><br><span class="line">                        <span class="keyword">var</span> messageRecieptHandle = message.ReceiptHandle;</span><br><span class="line">                        <span class="keyword">var</span> deleteMessageRequest = <span class="keyword">new</span> DeleteMessageRequest</span><br><span class="line">                        &#123;</span><br><span class="line">                            QueueUrl = myQueueUrl,</span><br><span class="line">                            ReceiptHandle = messageRecieptHandle</span><br><span class="line">                        &#125;;</span><br><span class="line">                        amazonSqsClient.DeleteMessage(deleteMessageRequest);</span><br><span class="line">                        Console.WriteLine(<span class="string">"Delete message: &#123;0&#125;"</span>, message.Body);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AmazonSQSException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Caught Exception: "</span> + ex.Message);</span><br><span class="line">                Console.WriteLine(<span class="string">"Response Status Code: "</span> + ex.StatusCode);</span><br><span class="line">                Console.WriteLine(<span class="string">"Error Code: "</span> + ex.ErrorCode);</span><br><span class="line">                Console.WriteLine(<span class="string">"Error Type: "</span> + ex.ErrorType);</span><br><span class="line">                Console.WriteLine(<span class="string">"Request ID: "</span> + ex.RequestId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"Press Enter to continue..."</span>);</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>39 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiveMessageRequest = <span class="keyword">new</span> ReceiveMessageRequest</span><br><span class="line">&#123;</span><br><span class="line">    QueueUrl = myQueueUrl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> receiveMessageResponse = amazonSqsClient.ReceiveMessage(receiveMessageRequest);</span><br></pre></td></tr></table></figure>
<p>建立 <code>ReceiveMessageRequest</code> DTO，其中 <code>QueueUrl</code> 為 queue 的 URL。</p>
<p>再將 <code>ReceiveMessageRequest</code> DTO 傳入 <code>AmazonSQSClient.ReceiveMessage()</code>，正式從 queue 讀出資料。</p>
<p>45 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (receiveMessageResponse.Messages != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> message = receiveMessageResponse.Messages[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(message.Body))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Read message: &#123;0&#125;"</span>, message.Body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>receiveMessageResponse.Messages</code> 為 <code>List&lt;Message&gt;</code>，預設每次 <code>ReceiveMessage()</code> 只會從 queue 讀出一筆 message，且資料在 <code>message.Body</code> 內。</p>
<p>55 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete message from FIFO queue</span></span><br><span class="line"><span class="keyword">var</span> messageRecieptHandle = message.ReceiptHandle;</span><br><span class="line"><span class="keyword">var</span> deleteMessageRequest = <span class="keyword">new</span> DeleteMessageRequest</span><br><span class="line">&#123;</span><br><span class="line">    QueueUrl = myQueueUrl,</span><br><span class="line">    ReceiptHandle = messageRecieptHandle</span><br><span class="line">&#125;;</span><br><span class="line">                        amazonSqsClient.DeleteMessage(deleteMessageRequest);</span><br></pre></td></tr></table></figure>
<p>建立 <code>DeleteMessageRequest</code> DTO，其中 <code>QueueUrl</code> 為 queue 的 URL；此外 <code>ReceipeHandle</code> 為要刪除 message 的 handle。</p>
<p><code>ReceipeHandle</code> 由 <code>message.ReceiptHandle</code> 獲得。</p>
<p>再將 <code>DeleteMessageRequest</code> DTO 傳入 <code>AmazonSQSClient.DeleteMessage()</code>，正式從 queue 刪除資料。</p>
<blockquote>
<p>根據 AWS SQS 特性，若不從 SQS 刪除 message， 若繼續下  <code>ReceiveMessage()</code> ，仍然會讀取到相同的 message，唯有刪除了 <code>message</code> 之後，才會依 FIFO 順序讀到下一筆 message</p>
</blockquote>
<p><img src="/images/aws/sqs/sqs010.png" alt="sqs010"></p>
<p>依序寫入 <code>message0</code>、<code>message1</code> 與 <code>message2</code> 三筆資料進有 FIFO 的 AWS SQS。</p>
<p><img src="/images/aws/sqs/sqs011.png" alt="sqs011"></p>
<p>依序讀出 <code>message0</code>、<code>message1</code> 與 <code>message2</code> 。</p>
<h2 id="Q&amp;A">Q&amp;A</h2><hr>
<blockquote>
<p>Q : 如何查看 AWS SQS API ?</p>
</blockquote>
<p><img src="/images/aws/sqs/sqs009.png" alt="sqs009"></p>
<p>到 <a href="https://docs.aws.amazon.com/sdkfornet/v3/apidocs/Index.html" target="_blank" rel="external">AWS SDK for .NET API Reference</a> 官網，查詢 <code>Amazon.SQS</code> 的 <code>AmazonSQSClient</code>，所有 SQS 的 API 都是由這裡展開出來。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>FIFO queue 與 Standard queue 最大的差異在於 <code>SendMessage()</code> 的 DTO 必須包含 <code>MessageGroupId</code>，才能保證相同 <code>MessageGroupId</code> 有 FIFO 的 <code>先進先出</code> 特性</li>
<li><code>ReceiveMessage()</code> 之後還必須 <code>DeleteMessage()</code>，才能確保 <code>SendMessage()</code> 會收到下一筆 message，否則仍然會繼續收到目前的 message</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/SQSFIFOSample" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://aws.amazon.com/" target="_blank" rel="external">AWS</a>, <a href="https://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/welcome.html" target="_blank" rel="external">AWS SDK for .NET Developer Guide</a><br><a href="https://aws.amazon.com/" target="_blank" rel="external">AWS</a>, <a href="https://aws.amazon.com/visualstudio/" target="_blank" rel="external">AWS Toolkit for Visual Studio</a><br><a href="https://aws.amazon.com/" target="_blank" rel="external">AWS</a>, <a href="https://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/sqs-apis-intro.html" target="_blank" rel="external">Messaging Using Amazon SQS</a><br><a href="https://aws.amazon.com/" target="_blank" rel="external">AWS</a>, <a href="https://docs.aws.amazon.com/sdkfornet/v3/apidocs/Index.html" target="_blank" rel="external">AWS SDK for .NET API Reference</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 .NET Framework 與 AWS Toolkit for Visual Studio]]>
    
    </summary>
    
      <category term=".NET Framework" scheme="http://oomusou.io/tags/NET-Framework/"/>
    
      <category term="AWS" scheme="http://oomusou.io/tags/AWS/"/>
    
  </entry>
  
</feed>
